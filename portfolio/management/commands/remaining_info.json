{
    "projetos": {
        "portfolio": {
            "name": "Portfolio",
            "subprojects": {
                "Portfolio FrontEnd": {
                    "name": "Portfolio FrontEnd",
                    "description": "Toda a infraestrutura visual e resposividade do site de portfolio. O FrontEnd foi construido inteiramente com vue com TypeScript",
                    "conclusion": "Com o objetivo de construir um FrontEnd organizado, dinamico e responsivo o uso de vue foi um enorme facilitador. O principal diferencial que me fez preferir o vue ao react foi devido a sua praticidade com a configuração inicial do projeto, fazendo com que eu pudesse focar nas outras mecanicas do site de maneira quase imediata.",
                    "code_ex": "<script setup lang=\"ts\">\r\nimport type { footerInfo } from '@\/utils\/class\/siteInfoClass';\r\n\r\n\r\ninterface Props {\r\n  info: footerInfo\r\n}\r\n\r\nconst props = defineProps<Props>()\r\n<\/script>\r\n\r\n<template>\r\n  <div class=\"footer_container\">\r\n    <div class=\"status\" :class=\"{offline: props.info.status}\">\r\n      <h1>{H}<\/h1>\r\n    <\/div>\r\n    <div class=\"bars\">\r\n      <div class=\"left_bar\">\r\n        <div>\r\n          <img src=\"https:\/\/via.placeholder.com\/10x10\" alt=\"last Update\">\r\n          <span>{{ props.info.lastUpdate }}<\/span>\r\n        <\/div>\r\n        <div>\r\n          <img src=\"https:\/\/via.placeholder.com\/10x10\" alt=\"views\">\r\n          <span>{{ props.info.views }}<\/span>\r\n        <\/div>\r\n        <div>\r\n          <img src=\"https:\/\/via.placeholder.com\/10x10\" alt=\"errors\">\r\n          <span>{{ props.info.errors }}<\/span>\r\n        <\/div>\r\n        <div>\r\n          <img src=\"https:\/\/via.placeholder.com\/10x10\" alt=\"alert\">\r\n          <span>{{ props.info.alert }}<\/span>\r\n        <\/div>\r\n      <\/div>\r\n      <div class=\"center_bar\">\r\n        <div>\r\n          <img src=\"https:\/\/via.placeholder.com\/10x10\" alt=\"\">\r\n          <span>{{ props.info.author }}<\/span>\r\n        <\/div>\r\n        <div>\r\n          <img src=\"https:\/\/via.placeholder.com\/10x10\" alt=\"\">\r\n          <span>{{ props.info.madeIn }}<\/span>\r\n        <\/div>\r\n      <\/div>\r\n      <div class=\"right_bar\">\r\n        <div>\r\n          <img v-for=\"(url, index) in props.info.expertise\" :src=\"url\" :key=\"index\">\r\n        <\/div>\r\n      <\/div>\r\n    <\/div>\r\n  <\/div>\r\n<\/template>\r\n\r\n<style scoped lang=\"scss\">\r\n@use '..\/assets\/sasss\/variables.scss' as *;\r\n\r\n.footer_container {\r\n  display: flex;\r\n  background-color: map-get($map: $footerColors, $key: primary);\r\n\r\n  .status {\r\n    background-color: map-get($map: $footerColors, $key: secondary);\r\n    width: 30px;\r\n    height: 30px;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n\r\n    h1 {\r\n      font-size: 16px;\r\n      font-family: $logoFont;\r\n      color: map-get($map: $footerColors, $key: font);\r\n    }\r\n  }\r\n\r\n  .offline {\r\n    background-color: map-get($map: $footerColors, $key: terciary);\r\n  }\r\n\r\n  .bars {\r\n    display: grid;\r\n    grid-template-columns: 1fr 1fr 1fr;\r\n    width: 100%;\r\n    margin-left: 8px;\r\n\r\n    .left_bar {\r\n      display: flex;\r\n\r\n      div {\r\n        display: flex;\r\n        align-items: center;\r\n        justify-content: center;\r\n\r\n        span {\r\n          font-size: 10px;\r\n          margin-left: 4px;\r\n          margin-right: 12px;\r\n          font-family: $codeFont;\r\n          color: map-get($map: $footerColors, $key: font);\r\n        }\r\n\r\n        img {\r\n          height: 15px;\r\n          width: 15px;\r\n        }\r\n      }\r\n    }\r\n\r\n    .center_bar {\r\n      display: flex;\r\n      justify-content: center;\r\n\r\n      div {\r\n        display: flex;\r\n        align-items: center;\r\n\r\n        span {\r\n          font-size: 10px;\r\n          margin-left: 4px;\r\n          margin-right: 12px;\r\n          font-family: $codeFont;\r\n          color: map-get($map: $footerColors, $key: font);\r\n        }\r\n\r\n        img {\r\n          height: 15px;\r\n          width: 15px;\r\n        }\r\n      }\r\n    }\r\n\r\n    .right_bar {\r\n      display: flex;\r\n      justify-content: flex-end;\r\n      margin-right: 8px;\r\n\r\n      div {\r\n        display: flex;\r\n        align-items: center;\r\n\r\n        img {\r\n          height: 15px;\r\n          width: 15px;\r\n          margin-left: 5px;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n<\/style>",
                    "status": "incomplete",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "Vue",
                    "projeto": "portfolio"
                },
                "portfolio BackEnd": {
                    "name": "Portfolio Backend",
                    "description": "Toda a infraestrutura de gestão do banco de dados do site de portfolio. O banco de dados foi criado com Postgres via Django rest framework.",
                    "conclusion": "A intenção de fazer um banco de dados foi otimizar e automatizar a coleta de dados facilitando assim a inserção de novas informação ao site.",
                    "code_ex": "from django.test import TestCase\r\nfrom portfolio.models import SubProjetoModel, ProjetoModel, TecnologiaModel\r\n\r\n\r\nclass SubProjetoModelTestCase(TestCase):\r\n    def setUp(self):\r\n        self.tecnologia = TecnologiaModel.objects.create(nome=\"Flask\")\r\n        self.projeto = ProjetoModel.objects.create(\r\n            name=\"Projeto Flask\",\r\n            status=0,\r\n            url=\"http:\/\/github.com\/projeto-flask\",\r\n            description=\"Projeto de exemplo em Flask\",\r\n            tecnologia=self.tecnologia,\r\n            icon=\"http:\/\/example.com\/project-flask.png\"\r\n        )\r\n        self.subprojeto = SubProjetoModel.objects.create(\r\n            name=\"SubProjeto Flask\",\r\n            description=\"SubProjeto detalhado em Flask\",\r\n            status=1,\r\n            tecnologia=self.tecnologia,\r\n            projeto=self.projeto,\r\n            icon=\"http:\/\/example.com\/subproject.png\"\r\n        )\r\n\r\n    def test_subprojeto_creation(self):\r\n        self.assertEqual(self.subprojeto.name, \"SubProjeto Flask\")\r\n        self.assertEqual(self.subprojeto.projeto.name, \"Projeto Flask\")\r\n        self.assertEqual(str(self.subprojeto), \"SubProjeto Flask\")\r\n",
                    "status": "incomplete",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "Python",
                    "projeto": "portfolio"
                }
            },
            "code_ex": "Nenhum codigo de exemplo apresentado.",
            "conclusion": "Com a intenção de fazer um site que representa as habilidades adquiridas nos ultimos anos na area de fullstack. Criei algo que exemplifique e deixe claro as ultimas habilidades adquiridas.",
            "icon": "https://via.placeholder.com/50x50",
            "status": "incomplete"
        },
        "Dungeon-2.5-RPG-C-": {
            "name": "Dungeon-2.5-RPG-C-",
            "subproject": {},
            "code_ex": "using Godot;\r\nusing System;\r\n\r\npublic partial class PlayerAttackState : PlayerState\r\n{\r\n    [Export] private Timer ResetCounter;\r\n    [Export] private PackedScene LightningScene;\r\n    private int ComboCounter = 1;\r\n    private int MaxCombo = 2;\r\n    public override void _Ready()\r\n    {\r\n        base._Ready();\r\n\r\n        ResetCounter.Timeout += () => ComboCounter = 1;\r\n    }\r\n    protected override void enterState()\r\n    {\r\n        characterNode.AnimPlayerNode.Play(GameConstants.ANIM_ATTACK + ComboCounter, -1, 2.5f);\r\n\r\n        characterNode.AnimPlayerNode.AnimationFinished += HandleAnimationFinished;\r\n        characterNode.Hitbox.BodyEntered += HandleBodyEntered;\r\n    }\r\n    protected override void exitState()\r\n    {\r\n        characterNode.AnimPlayerNode.AnimationFinished -= HandleAnimationFinished;\r\n        ResetCounter.Start();\r\n        characterNode.Hitbox.BodyEntered -= HandleBodyEntered;\r\n    }\r\n\r\n    private void HandleBodyEntered(Node3D body)\r\n    {\r\n        if (ComboCounter != MaxCombo)\r\n        {\r\n            return;\r\n        }\r\n\r\n        Node3D Lightning = LightningScene.Instantiate<Node3D>();\r\n        GetTree().CurrentScene.AddChild(Lightning);\r\n        Lightning.GlobalPosition = body.GlobalPosition;\r\n    }\r\n\r\n\r\n    private void HandleAnimationFinished(StringName animName)\r\n    {\r\n        ComboCounter = Mathf.Wrap(ComboCounter + 1, 1, 3);\r\n        characterNode.StateMachineNode.SwitchState<PlayerIdleState>();\r\n    }\r\n\r\n    private void PerformHit()\r\n    {\r\n        Vector3 NewPosition = characterNode.SpriteNode.FlipH ? Vector3.Left : Vector3.Right;\r\n        float DistanceMultiplayer = 0.75f;\r\n        characterNode.Hitbox.Position = NewPosition * DistanceMultiplayer;\r\n        characterNode.ToggleHitbox(false);\r\n    }\r\n\r\n    private void HideHit()\r\n    {\r\n        characterNode.Hitbox.Position = Vector3.Zero;\r\n        characterNode.ToggleHitbox(true);\r\n    }\r\n}",
            "conclusion": "Esse projeto foi criado para testar a compatibilidade do godot com C#, Apesar de ter percebido que C# é uma linguagem muito mais robusta que o GDScript, consegui concluir que quando trabalhando no godot a melhor ferramenta segue sendo o GDScript, sua praticidade e clareza já justifica a sua utilização.",
            "icon": "https://via.placeholder.com/50x50",
            "status": "completed"
        },
        "oOHimuraOo": {
            "name": "oOHimuraOo",
            "subproject": {},
            "code_Ex": "# \uD83D\uDCBB Hello World! I'm Felipe~ \t\t\t\r\n\uD83D\uDCDA * *Software Enginner*\r\n\r\nHi everyone! My name is Felipe, but everyone calls me Himura. It's a nickname from my childhood in the nineties, so you can call me whatever you prefer. I'm a fullstack developer who loves to meet new people and share experiences.\r\nYou can find me in the social medias bellow:\r\n\r\n[LinkedIn](https:\/\/www.linkedin.com\/in\/felipe-cerqueira-fernandes-974b4b257\/) |\r\n[Bluesky](https:\/\/bsky.app\/profile\/oohimuraoo.bsky.social)\r\n\r\n<div align=\"center\">\r\n  <a href=\"https:\/\/github.com\/oOHimuraOo\">\r\n  <!--<img height=\"180em\" src=\"https:\/\/github-readme-stats.vercel.app\/api?username=oOHimuraOo&show_icons=true&theme=dracula&include_all_commits=true&count_private=true\"\/>-->\r\n  <img height=\"180em\" src=\"https:\/\/github-readme-stats.vercel.app\/api\/top-langs\/?username=oOHimuraOo&layout=compact&langs_count=7&theme=dracula\"\/>\r\n<\/div> \r\n\r\n<div align=\"center\">\r\n  <img align=\"center\" alt=\"GD\" height=\"50\" width=\"50\" src=\"https:\/\/github.com\/user-attachments\/assets\/31e6d9a7-de7a-45b4-84a4-f9bfbbfa601f\">\r\n  <img align=\"center\" alt=\"Js\" height=\"50\" width=\"50\" src=\"https:\/\/raw.githubusercontent.com\/devicons\/devicon\/master\/icons\/javascript\/javascript-plain.svg\">\r\n  <img align=\"center\" alt=\"Ts\" height=\"50\" width=\"50\" src=\"https:\/\/raw.githubusercontent.com\/devicons\/devicon\/master\/icons\/typescript\/typescript-plain.svg\">\r\n  <img align=\"center\" alt=\"Python\" height=\"50\" width=\"50\" src=\"https:\/\/www.svgrepo.com\/show\/452091\/python.svg\">\r\n  <img align=\"center\" alt=\"HTML\" height=\"50\" width=\"50\" src=\"https:\/\/raw.githubusercontent.com\/devicons\/devicon\/master\/icons\/html5\/html5-original.svg\">\r\n  <img align=\"center\" alt=\"CSS\" height=\"50\" width=\"50\" src=\"https:\/\/raw.githubusercontent.com\/devicons\/devicon\/master\/icons\/css3\/css3-original.svg\">\r\n  <img align=\"center\" alt=\"Vue\" height=\"50\" width=\"50\" src=\"https:\/\/www.svgrepo.com\/show\/493625\/vue-vuejs-javascript-js-framework.svg\">\r\n  <img align=\"center\" alt=\"React\" height=\"50\" width=\"50\" src=\"https:\/\/raw.githubusercontent.com\/devicons\/devicon\/master\/icons\/react\/react-original.svg\">\r\n<\/div>\r\n\r\n\r\n## \u2728A little bit more about me:\r\n```js\r\n\tlet mySelf = {\r\n\t\tname: \"Felipe\",\r\n\t\tlastName: \"Cerqueira\",\r\n\t\tnickname: \"oOHimuraOo\",\r\n\t\tage: 33,\r\n\t\tcurrentlySpecializing: [\"TypeScript\", \"Python\", \"VUE\", \"GdScript\"],\r\n\t\tdescription: \"Im a Full Stack developer who loves to share my experience, meet new friends and learn even more\",\r\n\t\taddress:{\r\n\t\t\tcountry: \"Brazil\",\r\n\t\t\tstate: \"Bahia\",\r\n\t\t\tcity: \"Salvador\"\r\n\t\t},\r\n\t\tpassions:[\"Performance\", \"Software Design\", \"GameDev\", \"Open Source\", \"React\", \"Education\"]\r\n\t}\r\n```\r\n## \uD83D\uDD27 My Skills \r\n\r\nIm aways learning new things, the list above its a preview what im using or learning right now!\r\n\r\n ### Front End Skills\r\n\r\n - React\r\n - Javascript \r\n - Typescript\r\n - CSS\r\n - SASS\r\n - LESS\r\n - HTML (Learning a lot about accessibility, [you should it too](https:\/\/www.w3.org\/standards\/webdesign\/accessibility))\r\n\r\n### Back End Skills\r\n - Node\r\n - Performance Optimizations\r\n - Relational DataBases (Mysql, Sqlite, Postgres, etc)\r\n",
            "conclusion": "Repositorio criado automaticamente pelo github para configurar o perfil do github.",
            "icon": "https://via.placeholder.com/50x50",
            "status": "completed"
        },
        "CardGame": {
            "name": "CardGame",
            "subproject": {
                "Client/Versao 0.2": {
                    "name": "Client/Versao 0.2",
                    "description": "Como esse jogo foi pensado em ser um jogo online, ele foi dividido em dois lados. Um lado é chamado de client e o outro de server. Essa parte do projeto se refere apenas ao client, ou seja o lado em que o jogador interage.",
                    "conclusion": "Enquanto crio esse jogo consegui entender que até mesmo a mais simples atividade pode se tornar algo complicado se você não tiver experiencia durante o planejamento. Afinal para chegar até aqui eu tive que refazer o projeto inteiro 6 vezes, e muito provavelmente irei ter que recomeçar mais algumas vezes antes de conseguir finalizar. Planejar algo tendo em mente a comunicação online é um desafio que não deve ser subestimado.",
                    "code_ex": "class_name CARTA_BASE\r\nextends CARTA_REFERENCIAS\r\n\r\nsignal hover_iniciado(carta:CARTA_BASE)\r\nsignal hover_terminado(carta:CARTA_BASE)\r\nsignal carta_clicada(carta:CARTA_BASE)\r\n\r\n@export var carta_info: CARTA_INFO\r\n\r\nvar linha_atual:int = 0\r\nvar carta_no_deck:bool = false\r\n\r\nvar cor_de_tier:Dictionary = {\r\n\t\"TIER_0\": Color(\"#e7edea\"),\r\n\t\"TIER_1\": Color(\"#ffc52c\"),\r\n\t\"TIER_2\": Color(\"#fb0c06\"),\r\n\t\"TIER_3\": Color(\"#030d4f\")\r\n}\r\n\r\nvar cor_de_raridade:Dictionary = {\r\n\t\"MUITO_COMUM\": Color(\"#dac8b3\"),\r\n\t\"COMUM\": Color(\"#919a8b\"),\r\n\t\"INCOMUM\": Color(\"#bab8b5\"),\r\n\t\"RARO\": Color(\"#e7b555\"),\r\n\t\"MUITO_RARO\": Color(\"#b00300\")\r\n}\r\n\r\nvar copia_grafica:CARTA_BASE\r\nvar em_hover:bool = false\r\n\r\nfunc carregar_informacoes_da_carta(index:int, colecao:String) -> void:\r\n\tname = DATA.CardInfo[colecao][str(index)][\"Nome\"]\r\n\t\r\n\tcriar_recurso()\r\n\t\r\n\tvar textura_caminho = \"res:\/\/Assets\/Carta\/Imagem\/Cartas\/\" + DATA.CardInfo[colecao][str(index)][\"Imagem\"]\r\n\tcarta_info.imagem = load(textura_caminho)\r\n\t\r\n\tcarta_info.index = index\r\n\tcarta_info.colecao = colecao\r\n\t\r\n\tcarta_info.nome = DATA.CardInfo[colecao][str(index)][\"Nome\"]\r\n\tfor tipo in DATA.CardInfo[colecao][str(index)][\"Tipo\"]:\r\n\t\tcarta_info.tipo.append(tipo)\r\n\tcarta_info.tier = cor_de_tier[DATA.CardInfo[colecao][str(index)][\"Tier\"]] \r\n\tcarta_info.custo = DATA.CardInfo[colecao][str(index)][\"Valor\"]\r\n\tcarta_info.forca = DATA.CardInfo[colecao][str(index)][\"Ataque\"]\r\n\tcarta_info.defesa = DATA.CardInfo[colecao][str(index)][\"Defesa\"]\r\n\tcarta_info.raridade = cor_de_raridade[DATA.CardInfo[colecao][str(index)][\"Raridade\"]]\r\n\t\r\n\tif DATA.CardInfo[colecao][str(index)].has(\"Palavra-Chave\"):\r\n\t\tcarta_info.palavras_chave.append_array(DATA.CardInfo[colecao][str(index)][\"Palavra-Chave\"]) \r\n\t\r\n\tif DATA.CardInfo[colecao][str(index)].has(\"Efeito\"):\r\n\t\tcarta_info.efeito = DATA.CardInfo[colecao][str(index)][\"Efeito\"]\r\n\t\r\n\tupdate_visual()\r\n\tativar_palavras_chave()\r\n\r\nfunc criar_recurso() -> void:\r\n\tcarta_info = CARTA_INFO.new()\r\n\r\nfunc quando_botao_detector_de_carta_pressionada():\r\n\tcarta_clicada.emit(self)\r\n\r\nfunc update_visual() -> void:\r\n\tetiqueta_custo.set_text(str(carta_info.custo))\r\n\tetiqueta_ataque.set_text(str(carta_info.forca))\r\n\tetiqueta_defesa.set_text(str(carta_info.defesa))\r\n\tetiqueta_nome.set_text(carta_info.nome)\r\n\tif carta_info.tipo.size() == 1:\r\n\t\tetiqueta_tipo.set_text(carta_info.tipo[0])\r\n\telse:\r\n\t\tetiqueta_tipo.set_text(carta_info.tipo[0] + \", \" + carta_info.tipo[1])\r\n\tcor_tier.color = carta_info.tier\r\n\tborda_plano_de_fundo.self_modulate = carta_info.raridade\r\n\timagem_retrato_carta.set_texture(carta_info.imagem)\r\n\ttexto_descritivo.clear()\r\n\t\r\n\tfor palavra in carta_info.palavras_chave:\r\n\t\tif carta_info.palavras_chave.find(palavra) == 0:\r\n\t\t\ttexto_descritivo.set_text(palavra + \", \")\r\n\t\telse:\r\n\t\t\ttexto_descritivo.add_text(palavra + \", \")\r\n\r\nfunc ativar_palavras_chave() -> void:\r\n\tif carta_info.palavras_chave.is_empty():\r\n\t\treturn\r\n\t\r\n\tfor palavra in carta_info.palavras_chave:\r\n\t\tinstaciar_comportamento(palavra)\r\n\r\nfunc instaciar_comportamento(nome_do_comportamento:String) -> void:\r\n\tvar CIR: String = nome_do_comportamento.to_upper() + \"_CENA\"\r\n\tvar comportamento_instancia = CONS.get(CIR).instantiate()\r\n\tmaquina_de_comportamento.alocar_comportamento(comportamento_instancia)\r\n\tmaquina_de_comportamento.verificar_maquina_de_comportamento()\r\n\r\nfunc quando_botao_detector_de_carta_detectar_input(event):\r\n\tif event is InputEventMouseButton:\r\n\t\tif event.button_index == 4:\r\n\t\t\tlinha_atual -= 1\r\n\t\t\tif linha_atual < 0:\r\n\t\t\t\tlinha_atual = 0\r\n\t\t\t\r\n\t\t\ttexto_descritivo.scroll_to_line(linha_atual)\r\n\t\telif event.button_index == 5:\r\n\t\t\tlinha_atual += 1\r\n\t\t\tif linha_atual > texto_descritivo.get_line_count():\r\n\t\t\t\tlinha_atual = texto_descritivo.get_line_count()\r\n\t\t\t\r\n\t\t\ttexto_descritivo.scroll_to_line(linha_atual)\r\n\r\n\r\n\r\nfunc _input(event):\r\n\tif !em_hover && event is InputEventMouseButton && event.button_index == 2 && event.pressed == true:\r\n\t\tif get_global_mouse_position().x > self.global_position.x && get_global_mouse_position().x < self.global_position.x + 200:\r\n\t\t\tif get_global_mouse_position().y > self.global_position.y && get_global_mouse_position().y < self.global_position.y + 284:\r\n\t\t\t\tem_hover = true\r\n\t\t\t\thover_iniciado.emit(self)\r\n\t\t\t\treturn\r\n\t\r\n\tif em_hover && event is InputEventMouseButton && (event.button_index == 2 || event.button_index == 1) && event.pressed == true:\r\n\t\tem_hover = false\r\n\t\thover_terminado.emit(self)\r\n\t\treturn\r\n\r\nfunc aplicar_zoom_de_leitura(zoom:Vector2, posicao:Vector2, z:int) -> void:\r\n\tif !copia_grafica:\r\n\t\t#aplicar uma twen aqui\r\n\t\tcopia_grafica = duplicate()\r\n\t\tget_parent().add_child(copia_grafica)\r\n\t\tcopia_grafica.carregar_informacoes_da_carta(carta_info.index, carta_info.colecao)\r\n\t\tcopia_grafica.botao_detector_de_carta.set_disabled(true)\r\n\t\tcopia_grafica.scale = zoom\r\n\t\tcopia_grafica.global_position = posicao\r\n\t\tcopia_grafica.z_index = z\r\n\telse:\r\n\t\tcopia_grafica.queue_free()\r\n\t\tcopia_grafica = null",
                    "status": "incomplete",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "CardGame"
                },
                "Servidor/Versao 0.2": {
                    "name": "Servidor/Versao 0.2",
                    "description": "Visto que este é o lado do servidor, a ideia é que este seja responsavel por todos os tratamentos possiveis enviando então apenas as devidas soluções para o client. A comunicação planejada foi: Jogador envia uma solicitação para o servidor via o client, O servidor verifica se o a solicitação é valida, se for ele trata a solicitação calcula as possibilidades ajusta os modificadores gerais e só então o servidor notifica todos os clients de que essa modificação aconteceu entregando assim a resposta solicitada pelo client.",
                    "conclusion": "Bolar um sistema escalavel, capaz de calcular as interações dos clients e as multiplas chamadas simultaneas tem se mostrado um desafio. Principalmente quando você almeja criar um codigo simples, otimizado e organizado. infelizmente ainda não estou completamente satisfeito com o meu resultado atual, mas decidi que seria ideal finalizar o prototipo do projeto antes de começar a refazer tudo pela 7ª vez.",
                    "code_ex": "class_name ENVIANDO\r\nextends Node\r\n\r\nfunc servidor_client_usuario_autenticado(autenticado:bool, verificador:bool, id:int, status:String, usuario:String = \"\", senha:String = \"\") -> void:\r\n\tif usuario != \"\" && senha != \"\":\r\n\t\tget_parent().servidor_client_usuario_autenticado(autenticado, verificador, id, status, usuario, senha)\r\n\t\treturn\r\n\tget_parent().servidor_client_usuario_autenticado(autenticado, verificador, id, status)\r\n\r\nfunc servidor_client_falha_ao_criar_cadastro(id:int) -> void:\r\n\tget_parent().servidor_client_falha_ao_criar_cadastro(id)\r\n\r\nfunc servidor_client_sucesso_ao_criar_cadastro(id:int) -> void:\r\n\tget_parent().servidor_client_sucesso_ao_criar_cadastro(id)\r\n\r\nfunc coletar_informacao_do_jogador(id:int, usuario:String) -> void:\r\n\tvar usuario_real:String = get_parent().iniciando.aplicar_regra_hash_de_usuario(usuario)\r\n\tvar account_info:Dictionary = DATA.UserData[usuario_real][\"informcoes_do_jogador\"]\r\n\tget_parent().servidor_client_enviar_informacao_do_jogador(id, account_info)\r\n\r\nfunc coletar_informacoes_de_noticias(id:int) -> void:\r\n\tget_parent().servidor_client_enviar_noticias(id, DATA.NoticiasInfor)\r\n\r\nfunc abrir_booster(boosters:Dictionary, usuario:String, id:int) -> void:\r\n\trandomize()\r\n\tvar usuario_real:String = get_parent().iniciando.aplicar_regra_hash_de_usuario(usuario)\r\n\tvar copia_de_boosters: Dictionary = boosters.duplicate()\r\n\tfor edicao in copia_de_boosters:\r\n\t\tif DATA.UserData[usuario_real][\"informcoes_do_jogador\"][\"packs\"][edicao][\"quantidade\"] <= copia_de_boosters[edicao][\"quantidade\"]:\r\n\t\t\tcopia_de_boosters[edicao][\"quantidade\"] = DATA.UserData[usuario_real][\"informcoes_do_jogador\"][\"packs\"][edicao][\"quantidade\"]\r\n\t\r\n\tvar carta_tirada: Dictionary = {}\r\n\tfor edicao in copia_de_boosters:\r\n\t\tcarta_tirada[edicao] = {}\r\n\t\tfor x in range(copia_de_boosters[edicao][\"quantidade\"]):\r\n\t\t\tfor y in range(5):\r\n\t\t\t\tvar index:int = randi_range(0,DATA.EdicaoTamanhos[edicao][\"tamanho\"])\r\n\t\t\t\tif carta_tirada[edicao].has(str(index)):\r\n\t\t\t\t\tcarta_tirada[edicao][str(index)][\"quantidade\"] += 1\r\n\t\t\t\telse:\r\n\t\t\t\t\tcarta_tirada[edicao][str(index)] = {\"quantidade\": 1}\r\n\t\r\n\tfor edicao in copia_de_boosters:\r\n\t\tfor x in range(copia_de_boosters[edicao][\"quantidade\"]):\r\n\t\t\tDATA.UserData[usuario_real][\"informcoes_do_jogador\"][\"packs\"][edicao][\"quantidade\"] -= 1\r\n\t\r\n\tfor edicao in carta_tirada:\r\n\t\tfor carta in carta_tirada[edicao]:\r\n\t\t\tfor x in range(carta_tirada[edicao][carta][\"quantidade\"]):\r\n\t\t\t\tif DATA.UserData[usuario_real][\"informcoes_do_jogador\"][\"colecao\"].has(edicao):\r\n\t\t\t\t\tDATA.UserData[usuario_real][\"informcoes_do_jogador\"][\"colecao\"][edicao] += [int(carta)]\r\n\t\t\t\telse:\r\n\t\t\t\t\tDATA.UserData[usuario_real][\"informcoes_do_jogador\"][\"colecao\"][edicao] = [int(carta)]\r\n\t\r\n\tDATA.salvar_user_info()\r\n\tget_parent().servidor_client_enviar_cartas_tiradas(carta_tirada, id)\r\n\r\nfunc carregar_colecao(usuario:String, id:int) -> void:\r\n\tvar usuario_real:String = get_parent().iniciando.aplicar_regra_hash_de_usuario(usuario)\r\n\tvar colecao:Dictionary = DATA.UserData[usuario_real][\"informcoes_do_jogador\"][\"colecao\"]\r\n\tget_parent().servidor_client_enviar_colecao(colecao, id)\r\n\r\nfunc carregar_deck(id:int, usuario:String, nome_do_deck:String) -> void:\r\n\tvar usuario_real:String = get_parent().iniciando.aplicar_regra_hash_de_usuario(usuario)\r\n\tvar deck: Dictionary = DATA.UserData[usuario_real][\"informcoes_do_jogador\"][\"decks_do_jogador\"][nome_do_deck]\r\n\tget_parent().servidor_client_enviar_deck(deck, id)\r\n\r\nfunc finalizando_alteracao_de_deck(id:int, validacao:bool, msg:String) -> void:\r\n\tget_parent().servidor_client_enviar_resposta_de_validacao(id, validacao, msg)\r\n\r\nfunc jogador_em_fila_de_espera(id:int) -> void:\r\n\tget_parent().servidor_client_jogador_em_fila_de_espera(id)\r\n\r\nfunc jogador_saiu_da_fila(id:int) -> void:\r\n\tget_parent().servidor_client_jogador_saiu_da_fila_de_espera(id)\r\n\r\nfunc iniciar_partida(lobby:Array) -> void:\r\n\tvar array_de_ids:Array[int] = []\r\n\tfor player in lobby:\r\n\t\tarray_de_ids.append(int(CONLOB.jogadores_conectados[player].keys()[0])) \r\n\t\r\n\tget_parent().servidor_client_iniciar_partida(array_de_ids)",
                    "status": "incomplete",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "CardGame"
                }
            },
            "code_ex": "Nenhum codigo de exemplo apresentado.",
            "conclusion": "Esse é provavelmente um dos maiores projetos em que tenho trabalhado atualmente. Desenvolver um jogo em escala multiplayer tem se mostrado um desafio nas areas que eu menos esperava. Foi graças a esse projeto que comecei a pensar em como criar um bom planejamento.",
            "icon": "https://via.placeholder.com/50x50",
            "status": "incomplete"
        },
        "Coding-Challenges": {
            "name": "Coding-Challenges",
            "subproject": {
                "Coding Challenge 001 - Starfield Simulation": {
                    "name": "Coding Challenge 001 - Starfield Simulation",
                    "description": "This one was a simulation of a 3D plane in a 2D canvas. It is a math problem that tries to show how perspective can emulate a moving object.",
                    "conclusion": "In this project i learned that you com emmulate the movement in a 3d plane on a 2d canvas.",
                    "code_ex": "class_name DESENHO\r\nextends Control\r\n\r\nvar estrelas:Array = []\r\nvar velocidade:float = 50\r\n\r\nvar tamanhoDaTela:Vector2 = Vector2(1920,1080)\r\n\r\nfunc _ready():\r\n\tiniciar_tamanho_da_tela()\r\n\tfor i in range(max(tamanhoDaTela.x,tamanhoDaTela.y)):\r\n\t\testrelas.append(ESTRELA.new(tamanhoDaTela))\r\n\r\nfunc iniciar_tamanho_da_tela() -> void:\r\n\tget_viewport().size = tamanhoDaTela\r\n\tpivot_offset = tamanhoDaTela\/2\r\n\tprint(pivot_offset)\r\n\r\nfunc _process(_delta):\r\n\tqueue_redraw()\r\n\r\nfunc _input(_event) -> void:\r\n\tif Input.is_action_pressed('ui_up'):\r\n\t\tvelocidade += 0.5\r\n\t\tif velocidade > 400:\r\n\t\t\tvelocidade = 400\r\n\telif Input.is_action_pressed('ui_down'):\r\n\t\tvelocidade -= 0.5\r\n\t\tif velocidade < 1:\r\n\t\t\tvelocidade = 0.5\r\n\r\nfunc _draw():\r\n\tdraw_rect(Rect2(-tamanhoDaTela\/2,tamanhoDaTela),'000000')\r\n\tprint(velocidade)\r\n\tfor e in estrelas:\r\n\t\te.atualizar(velocidade)\r\n\t\te.revelar()\r\n\t\tdraw_circle(Vector2(e.sx,e.sy), e.r, 'ffffff')",
                    "status": "completed",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "Coding-Challenges"
                },
                "Coding Challenge 010 - Maze Generator": {
                    "name": "Coding Challenge 010 - Maze Generator",
                    "description": "This one was a challenge of how you can generate a random maze using an algorithm to check the next best possible way.",
                    "conclusion": "While i was making the visualization process it was a nice exercice becouse it made me think on what should i choose the best and optimized code or a code that it is not the most optimal, and what made me chose the later was the simple fact that it made easier to animate. and with a smooth animation the visualization made much more sense.While I was working on the visualization process, it was a nice exercise because it made me think about whether I should choose the best and most optimized code or a code that is not the most optimal. What made me choose the latter was the simple fact that it made it easier to animate. With a smooth animation, the visualization made much more sense.",
                    "code_ex": "class_name DESENHO\r\nextends Control\r\n\r\n@onready var celulaCena:PackedScene = preload(\"res:\/\/Cena\/Celula.tscn\")\r\n\r\nvar tamanhoDaTela:Vector2i = Vector2i(1920,1080)\r\nvar tamanhoDaCelula:float = 60\r\n\r\nvar celulas:Array = []\r\n\r\nvar celulaAtual:CELULA\r\nvar proximo\r\n\r\nvar colunas:float\r\nvar linhas:float\r\n\r\nvar pilha:Array = []\r\n\r\nfunc _ready():\r\n\tiniciar_tamanho_da_tela()\r\n\tiniciar_celulas()\r\n\tcelulaAtual = celulas.pick_random()\r\n\r\nfunc iniciar_tamanho_da_tela() -> void:\r\n\tget_viewport().size = tamanhoDaTela\r\n\r\nfunc iniciar_celulas() -> void:\r\n\tcolunas = tamanhoDaTela.x \/ tamanhoDaCelula\r\n\tlinhas = tamanhoDaTela.y \/ tamanhoDaCelula\r\n\tfor y in range(linhas):\r\n\t\tfor x in range(colunas):\r\n\t\t\tinstanciar_celula(x,y)\r\n\r\nfunc instanciar_celula(eixoX:float,eixoY:float) ->void:\r\n\tvar celula:CELULA = celulaCena.instantiate()\r\n\tcelula.p = Vector2(eixoX,eixoY) * tamanhoDaCelula\/2\r\n\tcelula.t = tamanhoDaCelula\r\n\tcelula.l = 1\r\n\tcelula.idX = eixoX\r\n\tcelula.idY = eixoY\r\n\tadd_child(celula)\r\n\tcelulas.append(celula)\r\n\r\nfunc _process(_delta):\r\n\tcelulaAtual.visitado = true\r\n\tcelulaAtual.atual = true\r\n\r\nfunc _on_timer_timeout():\r\n\tproximo = celulaAtual.verificar_visinho(celulas,colunas,linhas)\r\n\tif proximo != null:\r\n\t\tcelulaAtual.atual = false\r\n\t\tpilha.append(celulaAtual)\r\n\t\tremover_paredes(celulaAtual,proximo)\r\n\t\tcelulaAtual = proximo\r\n\telif pilha.size() > 0:\r\n\t\tvar celula:CELULA = pilha.pop_back()\r\n\t\tcelulaAtual = celula\r\n\r\nfunc _input(_event):\r\n\tif Input.is_action_just_pressed(\"ui_accept\"):\r\n\t\tget_tree().reload_current_scene()\r\n\r\nfunc remover_paredes(celula_a:CELULA, celula_b:CELULA) -> void:\r\n\tvar x = celula_a.idX - celula_b.idX\r\n\tif x == 1:\r\n\t\tcelula_a.paredesAtivas[3] = false\r\n\t\tcelula_b.paredesAtivas[1] = false\r\n\telif x == -1:\r\n\t\tcelula_a.paredesAtivas[1] = false\r\n\t\tcelula_b.paredesAtivas[3] = false\r\n\t\r\n\tvar y = celula_a.idY - celula_b.idY\r\n\tif y == 1:\r\n\t\tcelula_a.paredesAtivas[0] = false\r\n\t\tcelula_b.paredesAtivas[2] = false\r\n\telif y == -1:\r\n\t\tcelula_a.paredesAtivas[2] = false\r\n\t\tcelula_b.paredesAtivas[0] = false\r\n\t",
                    "status": "completed",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "Coding-Challenges"
                },
                "Coding Challenge 015 - Fractal Trees": {
                    "name": "Coding Challenge 015 - Fractal Trees",
                    "description": "This one uses the classical fractal problem to create a tree.",
                    "conclusion": "This was a simple representation of a direct mathematical algorithm, so while was fun to make it was not very dificult to do.",
                    "code_ex": "class_name DESENHO\r\nextends Node2D\r\n\r\n@onready var timer = $Timer\r\n\r\nvar tamanho_da_tela:Vector2i = Vector2i(1920,1080)\r\nvar tamanho_do_galho_inicial = 300\r\nvar arvore:Array = []\r\nvar folhas:Array = []\r\n\r\nvar contador:int = 0\r\nvar desenharFlores = false\r\nvar plano_de_fundo = false\r\n\r\nfunc _ready():\r\n\tget_viewport().size = tamanho_da_tela\r\n\tvar inicio:Vector2 = Vector2(tamanho_da_tela.x\/2,tamanho_da_tela.y)\r\n\tvar final:Vector2 = Vector2(tamanho_da_tela.x\/2,tamanho_da_tela.y - tamanho_do_galho_inicial)\r\n\tvar galho:GALHO = GALHO.new(inicio,final, randi_range(30,50))\r\n\tarvore.append(galho)\r\n\r\nfunc _process(_delta):\r\n\tfor i in range(arvore.size() -1, -1, -1):\r\n\t\tif !get_children().has(arvore[i]):\r\n\t\t\tarvore[i].revelar(self)\r\n\t\t\r\n\tqueue_redraw()\r\n\r\nfunc _draw():\r\n\tdraw_rect(Rect2(Vector2(0,0),tamanho_da_tela),'000000ff')\r\n\t\r\n\tif desenharFlores == true:\r\n\t\tfor folha in folhas:\r\n\t\t\tdraw_circle(folha, randi_range(4,16),'eabccd60')\r\n\t\t\tdraw_circle(folha+ Vector2(10,10), randi_range(4,16),'eabccd60')\r\n\t\t\tdraw_circle(folha+ Vector2(-10,-10), randi_range(4,16),'eabccd60')\r\n\t\t\tdraw_circle(folha+ Vector2(0,-10), randi_range(4,16),'eabccd60')\r\n\t\t\tdraw_circle(folha+ Vector2(0,10), randi_range(4,16),'eabccd60')\r\n\t\t\tdraw_circle(folha+ Vector2(10,0), randi_range(4,16),'eabccd60')\r\n\t\t\tdraw_circle(folha+ Vector2(-10,0), randi_range(4,16),'eabccd60')\r\n\t\t\tset_process(false)\r\n\t\t\t\r\n\r\n\r\nfunc _on_timer_timeout():\r\n\tprint(contador)\r\n\tif contador < 10:\r\n\t\tfor i in range(arvore.size() -1, -1, -1):\r\n\t\t\tif !arvore[i].terminado:\r\n\t\t\t\tarvore.append(arvore[i].galhoA())\r\n\t\t\t\tarvore.append(arvore[i].galhoB())\r\n\t\t\t\t#arvore.append(arvore[i].galhoC())\r\n\t\t\t\t#arvore.append(arvore[i].galhoD())\r\n\t\t\tarvore[i].terminado = true\r\n\t\tcontador += 1\r\n\telif contador == 10:\r\n\t\tfor i in range(arvore.size()):\r\n\t\t\tif !arvore[i].terminado:\r\n\t\t\t\tdesenharFlores = true\r\n\t\t\t\tvar folha = arvore[i].f\r\n\t\t\t\tfolhas.append(folha)\r\n\t\tcontador += 1\r\n\telse:\r\n\t\ttimer.stop()\r\n\t\tawait get_tree().create_timer(5).timeout\r\n\t\tget_tree().reload_current_scene()",
                    "status": "completed",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "Coding-Challenges"
                },
                "Coding Challenge 021 - Mandelbrot Set": {
                    "name": "Coding Challenge 021 - Mandelbrot Set",
                    "description": "This one is an illustration of the Mandelbrot set. It changes the color of every pixel on the screen to white or black. If it's white, it is out of the Mandelbrot set. This one is in urgent need of a remake because it is laggy. The way I chose to change the color was not optimal; it should have been made with a shader.",
                    "conclusion": "This one was the first challenge that when i made it i didn't have the full knoledge of how to make. So while i was capable of reproducing the end result i couldn't make it run smoothier. Today i know that i should have used shadder, and i will remake it one day.This was the first challenge where I didn't have the full knowledge of how to make it. While I was capable of reproducing the end result, I couldn't make it run smoother. Today, I know that I should have used shaders, and I will remake it one day.",
                    "code_ex": "class_name DESENHO\r\nextends Node2D\r\n@onready var camera_2d = $Camera2D\r\n\r\nvar valorMinimo:float = -1.5\r\nvar valorMaximo:float = 1.5\r\nvar valor:int = 0\r\nvar valor_antigo:int = 0\r\nvar telaTamanho:Vector2i\r\n\r\nfunc _ready() -> void:\r\n\ttelaTamanho = Vector2i(1200,1200)\r\n\taplicar_tamanho_de_tela(telaTamanho)\r\n\r\nfunc aplicar_tamanho_de_tela(tamanho:Vector2i) -> void:\r\n\tget_viewport().size = tamanho\r\n\r\nfunc _input(_event):\r\n\tif Input.is_mouse_button_pressed(MOUSE_BUTTON_WHEEL_DOWN):\r\n\t\tcamera_2d.zoom += Vector2(10,10)\r\n\t\tprint(camera_2d.zoom)\r\n\telif Input.is_mouse_button_pressed(MOUSE_BUTTON_WHEEL_UP):\r\n\t\tcamera_2d.zoom -= Vector2(10,10)\r\n\t\tif camera_2d.zoom < Vector2(0.2,0.2):\r\n\t\t\tcamera_2d.zoom = Vector2(0.1,0.1)\r\n\telif Input.is_action_just_pressed(\"ui_down\"):\r\n\t\tcamera_2d.position.y += 10\r\n\t\tprint(camera_2d.position)\r\n\telif Input.is_action_just_pressed('ui_up'):\r\n\t\tcamera_2d.position.y -= 10\r\n\t\tprint(camera_2d.position)\r\n\telif Input.is_action_just_pressed('ui_left'):\r\n\t\tcamera_2d.position.x -= 10\r\n\t\tprint(camera_2d.position)\r\n\telif Input.is_action_just_pressed('ui_right'):\r\n\t\tcamera_2d.position.x += 10\r\n\t\tprint(camera_2d.position)\r\n\telif Input.is_action_just_pressed(\"ui_accept\"):\r\n\t\tget_tree().reload_current_scene()\r\n\r\nfunc desenhar(valor_grupo) -> void:\r\n\tvar iteracoes_maximas:int = 1000\r\n\tfor x in range(valor_grupo):\r\n\t\tfor y in range(valor_grupo):\r\n\t\t\tif x >= valor_antigo || y >= valor_antigo:\r\n\t\t\t\tvar a:float = remap(x,0, telaTamanho.x, valorMinimo, valorMaximo)\r\n\t\t\t\tvar b:float = remap(y,0, telaTamanho.y, valorMinimo, valorMaximo)\r\n\t\t\t\t\r\n\t\t\t\tvar ca:float = a\r\n\t\t\t\tvar cb:float = b\r\n\t\t\t\t\r\n\t\t\t\tvar n:int = 0\r\n\t\t\t\t\r\n\t\t\t\twhile n < iteracoes_maximas:\r\n\t\t\t\t\tvar aa:float = a * a - b * b\r\n\t\t\t\t\tvar bb:float = 2 * a * b\r\n\t\t\t\t\t\r\n\t\t\t\t\ta = aa + ca\r\n\t\t\t\t\tb = bb + cb\r\n\t\t\t\t\t\r\n\t\t\t\t\tif a * a + b * b > 16:\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\r\n\t\t\t\t\tn += 1\r\n\t\t\t\t\r\n\t\t\t\tvar brilho = remap(n, 0, iteracoes_maximas, 0, 1)\r\n\t\t\t\tbrilho = remap(sqrt(brilho), 0, 1, 0, 255)\r\n\t\t\t\t\r\n\t\t\t\tif n == iteracoes_maximas:\r\n\t\t\t\t\tbrilho = 0\r\n\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tvar retanguloDeTextura:TextureRect = TextureRect.new()\r\n\t\t\t\tretanguloDeTextura.size = Vector2(1,1)\r\n\t\t\t\tretanguloDeTextura.self_modulate = Color(brilho,brilho,brilho,255)\r\n\t\t\t\tretanguloDeTextura.texture = Texture2D.new()\r\n\t\t\t\tretanguloDeTextura.expand_mode = TextureRect.EXPAND_IGNORE_SIZE\r\n\t\t\t\tretanguloDeTextura.global_position = Vector2(x,y)\r\n\t\t\t\tadd_child(retanguloDeTextura)\r\n\r\nfunc _process(_delta) -> void:\r\n\tvalor_antigo = valor\r\n\tif valor < telaTamanho.x || valor < telaTamanho.y:\r\n\t\tvalor += 1\r\n\t\tdesenhar(valor)\r\n\telse:\r\n\t\tset_process(false)",
                    "status": "incomplete",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "Coding-Challenges"
                },
                "Coding Challenge 033 - Poisson-Disc Sampling": {
                    "name": "Coding Challenge 033 - Poisson-Disc Sampling",
                    "description": "This one is a graphical representation of the Poisson-disc sample algorithm. It is used to create multiple random points on a canvas where none of the points are too far away or too close to another point. The program is finished when the canvas only has blue dots.",
                    "conclusion": "With this project, I learned how to create a uniform randomized distribution in a way that doesn't overload the system. It was a good lesson in optimization. However, to create a nice visualization, I needed to slow down the calculations.",
                    "code_ex": "class_name DESENHO\r\nextends Node2D\r\n\r\nvar nulo:Vector2 = Vector2(1826397.1823,1298376.812763)\r\nvar raio_limite:float = 30\r\nvar constante_de_tentativas:float = 30\r\nvar tamanho_da_tela:Vector2i = Vector2i(1920,1080)\r\n\r\nvar mapeamento:Array\r\n\r\nvar coluna:int #representa o eixo x do array.\r\nvar linha:int #representa o eixo y do array.\r\nvar dimensoes:Array = [coluna,linha] #o tamanho do array indica a quantidade de dimens\u00F5es e os valores dentro dele, o tamanho de cada eixo.\r\nvar tamanho_da_celula:float = raio_limite \/ sqrt(dimensoes.size())\r\n\r\nvar ativos:Array = []\r\nvar ordenado:Array = []\r\n\r\nfunc _ready():\r\n\tget_viewport().size = tamanho_da_tela\r\n\t\r\n\t#PASSO 0: Inicializa um mapa de \"n\" dimensoes para armazenar as amostras e acelerar a proximas buscas. O tamanho\r\n\t# de cada celula do mapa precisa ser limitada pela variavel Tamanho_da_celula, fazendo assim com que cada celula tenha\r\n\t# no maximo 1 amostra. Sendo assim o numero armazenado no array dever\u00E1 indicar o index da amostra localizada na celula,\r\n\t# caso n\u00E3o exista nenhuma amostra na celula o valor armazenado \u00E9 comumente -1.\r\n\t\r\n\tcoluna = round(tamanho_da_tela.x\/tamanho_da_celula)\r\n\tlinha = round(tamanho_da_tela.y\/tamanho_da_celula)\r\n\tfor i in range(dimensoes.size()):\r\n\t\tif i == 0: #se a imagem tiver todos os lados iguais voc\u00EA n\u00E3o precisa desse verificador. estou mantendo pq pretendo colocar array de diferentes tamanhos.\r\n\t\t\tdimensoes[i] = coluna\r\n\t\telse:\r\n\t\t\tdimensoes[i] = linha\r\n\tmapeamento = criar_um_array_de_N_dimensoes(dimensoes)\r\n\tfor i in range(coluna):\r\n\t\tfor j in range(linha):\r\n\t\t\tmapeamento[i][j] = nulo\r\n\t\r\n\t#PASSO 1: selecione aleatoriamente uma amostra qualquer. insira no seu array multidimensional e \r\n\t#inicialize a lista de amostras ativas com indice [0].\r\n\t\r\n\tvar x:float = tamanho_da_tela.x \/2\r\n\tvar y:float = tamanho_da_tela.y \/2\r\n\tvar index_X = round(x\/tamanho_da_celula)\r\n\tvar index_y = round(y\/tamanho_da_celula)\r\n\tvar pos:Vector2 = Vector2(index_X,index_y)\r\n\tmapeamento[index_X][index_y] = pos\r\n\tativos.append(pos)\r\n\r\nfunc criar_um_array_de_N_dimensoes(dim:Array) -> Array:\r\n\tif dim.size() < 1:\r\n\t\treturn [] #o valor deve ser mantido vazio, e acrescentado posteriormente fora dessa fun\u00E7\u00E3o.\r\n\tvar resultado = []\r\n\tvar size = dim[0]\r\n\tfor i in range(size):\r\n\t\tresultado.append(criar_um_array_de_N_dimensoes(dim.slice(1)))\r\n\treturn resultado\r\n\r\nfunc _process(_delta):\r\n\tif ativos.size() > 0:\r\n\t\tqueue_redraw()\r\n\r\nfunc _draw():\r\n\tdraw_rect(Rect2(Vector2(0,0),tamanho_da_tela),'000000')\r\n\t\r\n\t# passo 2: enquanto a lista de amostras ativas n\u00E3o estiver vazia, escolha um index aleatorio a partir\r\n\t# do slot da amostra ativa atual e gere uma quantidade de pontos igual a constante_de_tentativas, levando\r\n\t# em considera\u00E7\u00E3o uma area que seja entre 2r e r ao redor da amostra ativa.  Para cada ponto verifique se dentro \r\n\t# de sua area existem outros pontos. Se o ponto estiver adequadamente distante de todos os outros pontos desenhe-o\r\n\t# e acrescente-o a lista de amostras ativas. Caso se apos uma quantidade de tentativas igual a constante_de_tentativas,\r\n\t# n\u00E3o existir pontos a serem adicionados remova a amostra atual da lista de amostras ativas.\r\n\t\r\n\t#while ativos.size() > 0: nesse modo os pixels s\u00E3o desenhados todos em um frame s\u00F3. \r\n\tif (ativos.size() > 0): #nesse modo os pixels s\u00E3o desenhados a cada frame. Apesar de mais bonito. Muito mais lento\r\n\t\tvar indexAleatorio:int = randi_range(0,ativos.size()-1)\r\n\t\tvar pos:Vector2 = ativos[indexAleatorio]\r\n\t\tvar encontrado:bool = false\r\n\t\tfor n in range(constante_de_tentativas):\r\n\t\t\tvar amostra:Vector2 = Vector2(randf_range(-1,1),randf_range(-1,1))\r\n\t\t\tvar magnitude:float = randf_range(raio_limite, 2*raio_limite)\r\n\t\t\tamostra = amostra * magnitude\r\n\t\t\tamostra = amostra + pos\r\n\t\t\t\r\n\t\t\tvar col:int = floor(amostra.x\/tamanho_da_celula)\r\n\t\t\tvar lin:int = floor(amostra.y\/tamanho_da_celula)\r\n\t\t\t\r\n\t\t\tif col > -1 && lin > -1 && col < coluna && lin < linha && mapeamento[col][lin] == nulo: \r\n\t\t\t\tvar ok:bool = true\r\n\t\t\t\tfor x in range(-1,2):\r\n\t\t\t\t\tfor y in range(-1,2):\r\n\t\t\t\t\t\tvar indice_x:int = col + x \r\n\t\t\t\t\t\tvar indice_y:int = lin + y \r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif indice_x < coluna && indice_y < linha:\r\n\t\t\t\t\t\t\tvar visinho:Vector2 = mapeamento[indice_x][indice_y]\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif visinho != nulo:\r\n\t\t\t\t\t\t\t\tvar distancia:float = amostra.distance_to(visinho)\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tif distancia < raio_limite:\r\n\t\t\t\t\t\t\t\t\tok = false\r\n\t\t\t\tif ok:\r\n\t\t\t\t\tencontrado = true\r\n\t\t\t\t\tmapeamento[col][lin] = amostra\r\n\t\t\t\t\tativos.append(amostra)\r\n\t\t\t\t\tordenado.append(amostra)\r\n\t\t\t\t\tbreak\r\n\t\t\r\n\t\tif !encontrado:\r\n\t\t\tativos.remove_at(indexAleatorio)\r\n\t\t\r\n\tfor a in range(ordenado.size()):\r\n\t\tdraw_circle(ordenado[a],raio_limite\/4, '0000ff')\r\n\t\r\n\tfor b in range(ativos.size()):\r\n\t\tdraw_circle(ativos[b],raio_limite\/4, 'ff0000')\r\n\r\nfunc _input(_event):\r\n\tif Input.is_action_just_pressed(\"ui_accept\"):\r\n\t\tget_tree().reload_current_scene()",
                    "status": "completed",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "Coding-Challenges"
                },
                "Coding Challenge 035 - Travelling salesperson (TSP)": {
                    "name": "Coding Challenge 035 - Travelling salesperson (TSP)",
                    "description": "This one is graphical representation of some of the solutions to the TSP mathematical problem.",
                    "conclusion": "pending completion",
                    "code_ex": "class_name TSP_COM_GENETIC_ALGORITHM\r\nextends Node2D\r\n\r\nconst tspMenu:PackedScene = preload(\"res:\/\/Cena\/TSPMenu.tscn\")\r\n\r\n@onready var label = $Label\r\n\r\nvar tamanhoTela:Vector2i = Vector2i(1920,1080)\r\nvar resolucao:Vector2i = Vector2i(2260,1200)\r\n\r\nvar totalCidades:int = 5\r\nvar cidades:Array = []\r\n\r\nvar populacaoTamanho:int = 500\r\nvar pontuacao:Array = []\r\nvar populacao:Array = []\r\n\r\nvar permutacoesTotais:float\r\nvar contador:float\r\n\r\nvar linha_caminho:Line2D\r\nvar linha_calculo:Line2D\r\n\r\nvar distanciaRecord:float = INF\r\nvar melhorCaminhoEncontrado:Array\r\nvar melhorCaminhoAtual:Array\r\n\r\nfunc _ready():\r\n\tiniciar_padronizacao_tela()\r\n\tvar ordem:Array = etapa_0_montagem()\r\n\tetapa_1_registro(ordem)\r\n\tpermutacoesTotais = fatorar(totalCidades)\r\n\r\nfunc iniciar_padronizacao_tela() -> void:\r\n\tvar pos_offset:Vector2 = resolucao - tamanhoTela\r\n\tget_viewport().size = tamanhoTela\r\n\tget_window().position = Vector2(pos_offset.x\/2,pos_offset.y\/2)\r\n\r\nfunc etapa_0_montagem() -> Array:\r\n\tvar ordem:Array = []\r\n\tfor i:int in range(totalCidades):\r\n\t\tvar cidade:Vector2 = Vector2(randi_range(0,tamanhoTela.x),randi_range(0,tamanhoTela.y - 100))\r\n\t\tcidades.append(cidade)\r\n\t\tordem.append(i)\r\n\t\r\n\tlinha_caminho = Line2D.new()\r\n\tlinha_caminho.width = 4\r\n\tlinha_caminho.default_color = 'ff0000'\r\n\t\r\n\tlinha_calculo = Line2D.new()\r\n\tlinha_calculo.width = 1\r\n\tlinha_calculo.default_color = 'ffffff75'\r\n\t\r\n\tfor i in range(totalCidades):\r\n\t\tlinha_caminho.add_point(cidades[i])\r\n\t\tlinha_calculo.add_point(cidades[i])\r\n\t\r\n\tadd_child(linha_caminho)\r\n\tadd_child(linha_calculo)\r\n\treturn ordem\r\n\r\nfunc etapa_1_registro(ordem:Array) -> void:\r\n\tfor i in range(populacaoTamanho):\r\n\t\tvar novaOrdem:Array = ordem.duplicate()\r\n\t\tnovaOrdem.shuffle()\r\n\t\tpopulacao.append(novaOrdem)\r\n\r\nfunc fatorar(n:float) -> float:\r\n\tif n <= 1:\r\n\t\treturn n\r\n\telse:\r\n\t\treturn n * fatorar(n-1)\r\n\r\nfunc calcular_distancia(pontos:Array, posicao:Array) -> float:\r\n\tvar soma:float = 0.0\r\n\tfor i:int in range(posicao.size() -1):\r\n\t\tvar idxA:int = posicao[i]\r\n\t\tvar cidadeA:Vector2 = pontos[idxA]\r\n\t\tvar idxB:int = posicao[i+1]\r\n\t\tvar cidadeB:Vector2 = pontos[idxB]\r\n\t\t\r\n\t\tvar distancia:float = cidadeA.distance_to(cidadeB)\r\n\t\t\r\n\t\tsoma += distancia\r\n\t\r\n\treturn soma\r\n\t\r\nfunc trocar_posicoes_do_array(pontos:Array, idx_A:int, idx_B:int) -> void:\r\n\tvar temp = pontos[idx_A]\r\n\tpontos[idx_A] = pontos[idx_B]\r\n\tpontos[idx_B] = temp\r\n\r\nfunc atualizar_linha_calculo() -> void:\r\n\tfor i:int in range(melhorCaminhoAtual.size()):\r\n\t\tvar idx:int = melhorCaminhoAtual[i]\r\n\t\tlinha_calculo.set_point_position(i,cidades[idx])\r\n\r\nfunc atualizar_linha_caminho() -> void:\r\n\tfor i:int in range(melhorCaminhoEncontrado.size()):\r\n\t\tvar idx:int = melhorCaminhoEncontrado[i]\r\n\t\tlinha_caminho.set_point_position(i,cidades[idx])\r\n\r\nfunc _process(_delta):\r\n\tcalcular_pontuacao()\r\n\tnormalizar_pontuacao()\r\n\tproxima_geracao()\r\n\tatualizar_linha_calculo()\r\n\tatualizar_linha_caminho()\r\n\tLX_etapa_4_calcular_percentagem()\r\n\r\nfunc calcular_pontuacao() -> void:\r\n\tvar recordAtual:float = INF\r\n\t\r\n\tfor i in range(populacao.size()):\r\n\t\tvar distancia:float = calcular_distancia(cidades, populacao[i])\r\n\t\tif distancia < distanciaRecord:\r\n\t\t\tdistanciaRecord = distancia\r\n\t\t\tmelhorCaminhoEncontrado = populacao[i]\r\n\t\tif distancia < recordAtual:\r\n\t\t\trecordAtual = distancia\r\n\t\t\tmelhorCaminhoAtual = populacao[i]\r\n\t\tpontuacao.append(1\/(pow(distancia,8)+1))\r\n\r\nfunc normalizar_pontuacao() -> void:\r\n\tvar soma:float = 0\r\n\tfor i in range(pontuacao.size()):\r\n\t\tsoma += pontuacao[i]\r\n\tfor i in range(pontuacao.size()):\r\n\t\tpontuacao[i] = pontuacao[i]\/soma\r\n\r\nfunc proxima_geracao() -> void:\r\n\tvar novaPopulacao:Array = []\r\n\t\r\n\tfor i in range(populacao.size()):\r\n\t\tvar ordemA = selecionar_um(populacao, pontuacao)\r\n\t\tvar ordemB = selecionar_um(populacao, pontuacao)\r\n\t\tvar ordem = mesclar(ordemA, ordemB)\r\n\t\tmutacionar(ordem, 0.01)\r\n\t\tnovaPopulacao.append(ordem) \r\n\tpopulacao = novaPopulacao\r\n\tcontador += 1\r\n\tif contador == permutacoesTotais:\r\n\t\tset_process(false)\r\n\t\tawait get_tree().create_timer(5).timeout\r\n\t\tvoltar_pro_menu()\r\n\r\nfunc voltar_pro_menu() -> void:\r\n\tself.queue_free()\r\n\r\nfunc selecionar_um(pop:Array, pont:Array) -> Array:\r\n\tvar index:int = 0\r\n\tvar rand:float = randf()\r\n\t\r\n\twhile rand > 0:\r\n\t\trand -= pont[index]\r\n\t\tindex += 1\r\n\tindex -= 1\r\n\treturn pop[index].duplicate()\r\n\r\nfunc mesclar(ordemA:Array,ordemB:Array) -> Array:\r\n\tvar inicio:int = randi_range(0, ordemA.size() -1)\r\n\tvar final:int = randi_range(inicio + 1, ordemA.size() - 1)\r\n\r\n\tvar novaOrdem = ordemA.slice(inicio,final)\r\n\tfor i in range(ordemB.size()):\r\n\t\tvar cidade = ordemB[i]\r\n\t\tif !novaOrdem.has(cidade):\r\n\t\t\tnovaOrdem.append(cidade)\r\n\treturn novaOrdem\r\n\r\nfunc mutacionar(ordem, indiceDeMutcao) -> void:\r\n\tfor i in range(totalCidades):\r\n\t\tif randf_range(0,1) < indiceDeMutcao:\r\n\t\t\tvar indexA = randi_range(0, ordem.size() -1)\r\n\t\t\tvar indexB = (indexA + 1) % totalCidades\r\n\t\t\ttrocar_posicoes_do_array(ordem, indexA, indexB)\r\n\r\nfunc _draw():\r\n\tdraw_rect(Rect2(Vector2(0,0),tamanhoTela),'000000')\r\n\t\r\n\tfor i in totalCidades:\r\n\t\tdraw_arc(cidades[i],8,0,359,36,'ff00ff')\r\n\r\nfunc LX_etapa_4_calcular_percentagem() -> void:\r\n\tvar calculo:float = 100.00 * (contador\/permutacoesTotais)\r\n\tvar porcentagem:String = \"%*.*f\"\r\n\tlabel.position = Vector2(0,tamanhoTela.y-70)\r\n\tlabel.size = Vector2(tamanhoTela.x,tamanhoTela.y - (tamanhoTela.y - 70))\r\n\tlabel.set_text(porcentagem % [3,2, calculo]  + '% completo')",
                    "status": "completed",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "Coding-Challenges"
                },
                "Coding Challenge 054 - Islamic Star Pattern": {
                    "name": "Coding Challenge 054 - Islamic Star Pattern",
                    "description": "This one is a graphical representation of the classical Islamic tiles that you can see in buildings. It uses math to calculate the new shapes and create beautiful images.",
                    "conclusion": "pending completion",
                    "code_ex": "extends Control\r\n\r\n@onready var container_de_tiles:MarginContainer = $VBoxContainer\/ContainerDeTiles\r\n@onready var slider_angulo:HSlider = $VBoxContainer\/Sliders\/SliderAngulo\r\n@onready var slider_delta:HSlider = $VBoxContainer\/Sliders\/SliderDelta\r\n@onready var slider_incremento:HSlider = $VBoxContainer\/Sliders\/SliderIncremento\r\n@onready var slider_forma_g = $VBoxContainer\/Sliders\/SliderFormaG\r\n@onready var borda_cor = $VBoxContainer\/Sliders\/BordaCor\r\n@onready var hankin_cor = $VBoxContainer\/Sliders\/HankinCor\r\n\r\nvar poligonos:Array = []\r\n\r\nvar angulo:float = 75\r\nvar delta:float = 0.0\r\nvar incremento:float = 300\r\n\r\nvar largura:int\r\nvar altura:int\r\nvar tamanhoTela:Vector2i = Vector2i(1920,1080)\r\nvar resolucaoTela:Vector2i = Vector2i(2260,1200)\r\n\r\nvar numeroDeLados:int = 4\r\nvar cor1:Color = 'ffff00'\r\nvar cor2:Color = 'ffffff'\r\n\r\nfunc _ready():\r\n\tiniciar_padronizacao_tela()\r\n\tangulo = slider_angulo.value\r\n\tdelta = slider_delta.value\r\n\tincremento = slider_incremento.value\r\n\tnumeroDeLados = slider_forma_g.value\r\n\tlargura = tamanhoTela.x \/ incremento\r\n\taltura = (tamanhoTela.y - 30) \/ incremento\r\n\tawait get_tree().create_timer(0.1).timeout\r\n\tinicializar_tiles()\r\n\r\nfunc iniciar_padronizacao_tela() -> void:\r\n\tvar pos_offset:Vector2 = resolucaoTela - tamanhoTela\r\n\tget_viewport().size = tamanhoTela\r\n\tget_window().position = Vector2(pos_offset.x\/2,pos_offset.y\/2)\r\n\r\nfunc _draw():\r\n\tdraw_rect(Rect2(Vector2(0,0),tamanhoTela), '000000')\r\n\r\nfunc inicializar_tiles() -> void:\r\n\tfor x in range(largura):\r\n\t\tfor y in range(altura):\r\n\t\t\tvar poli:POLIGONO = POLIGONO.new()\r\n\t\t\tcontainer_de_tiles.add_child(poli)\r\n\t\t\tpoli.criar_poligono_regular(numeroDeLados,x,y,incremento, cor1, cor2)\r\n\t\t\tpoli.fechar(cor1, cor2)\r\n\t\t\tpoli.criar_hankin(angulo,delta, cor1, cor2)\r\n\t\t\tpoligonos.append(poli)\r\n\r\nfunc limpar_tiles() -> void:\r\n\tfor poli:POLIGONO in poligonos:\r\n\t\tpoli.queue_free()\r\n\tpoligonos.clear()\r\n\r\nfunc _on_slider_angulo_value_changed(value):\r\n\tangulo = value\r\n\tlimpar_tiles()\r\n\tinicializar_tiles()\r\n\r\n\r\nfunc _on_slider_delta_value_changed(value):\r\n\tdelta = value\r\n\tlimpar_tiles()\r\n\tinicializar_tiles()\r\n\r\n\r\nfunc _on_slider_incremento_value_changed(value):\r\n\tincremento = value\r\n\tlargura = tamanhoTela.x \/ incremento\r\n\taltura = (tamanhoTela.y - 30) \/ incremento\r\n\tlimpar_tiles()\r\n\tinicializar_tiles()\r\n\r\n\r\nfunc _on_slider_forma_g_value_changed(value):\r\n\tnumeroDeLados = value\r\n\tlimpar_tiles()\r\n\tinicializar_tiles()\r\n\r\n\r\nfunc _on_borda_cor_color_changed(color):\r\n\tcor1 = color\r\n\tlimpar_tiles()\r\n\tinicializar_tiles()\r\n\r\n\r\nfunc _on_hankin_cor_color_changed(color):\r\n\tcor2 = color\r\n\tlimpar_tiles()\r\n\tinicializar_tiles()",
                    "status": "completed",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "Coding-Challenges"
                },
                "Coding Challenge 056 - Attraction Forces": {
                    "name": "Coding Challenge 056 - Attraction Forces",
                    "description": "This one is just an emulation of the attraction forces. The pink circles attract the white circles. The bigger the pink circle, the greater the force. The velocity of the white circle is obtained by calculating the influence of the pink circle's mass on the white circle's mass. The mass is represented by the size of the circle.",
                    "conclusion": "pending completion",
                    "code_ex": "class_name DESENHO\r\nextends Node2D\r\n\r\n@onready var atract = $Atract\r\n@onready var partic = $Partic\r\n\r\nvar atratores:Array = []\r\nvar particulas:Array = []\r\n\r\nvar tamanhoTela:Vector2i = Vector2i(1920,1080)\r\nvar resolucaoTela:Vector2i = Vector2i(2260,1200)\r\n\r\nfunc _ready():\r\n\trandomize()\r\n\tinicializando_tela()\r\n\tfor i in range(10):\r\n\t\tvar atrator = ATRATOR.new(randi_range(0,tamanhoTela.x),randi_range(0,tamanhoTela.y),randi_range(50,200))\r\n\t\tatract.add_child(atrator)\r\n\t\tatratores.append(atrator)\r\n\tfor i in range(100):\r\n\t\tvar particula = PARTICULA.new(randi_range(0,tamanhoTela.x),randi_range(0,tamanhoTela.y),randi_range(4,40))\r\n\t\tpartic.add_child(particula)\r\n\t\tparticulas.append(particula)\r\n\r\nfunc inicializando_tela() -> void:\r\n\tvar pos_offset =  resolucaoTela - tamanhoTela\r\n\tget_viewport().size = tamanhoTela\r\n\tget_window().position = pos_offset\/2\r\n\r\nfunc _process(delta):\r\n\tfor particula in particulas:\r\n\t\tfor atrator:ATRATOR in atratores:\r\n\t\t\tparticula.atracao(atrator)\r\n\t\t\tif particula.fora_do_limite():\r\n\t\t\t\tparticula.queue_free()\r\n\t\t\t\tparticulas.erase(particula)\r\n\t\t\tif particula.intesepta(atrator):\r\n\t\t\t\tatrator.m = atrator.m - particula.m\r\n\t\t\t\tatrator.queue_redraw()\r\n\t\t\t\tparticula.queue_free()\r\n\t\t\t\tparticulas.erase(particula)\r\n\t\t\tif atrator.m < 10:\r\n\t\t\t\tfor i in range(20):\r\n\t\t\t\t\tvar par = PARTICULA.new(randi_range(atrator.p.x,atrator.p.x + randi_range(50,200)),randi_range(atrator.p.y,atrator.p.y + randi_range(50,200)),randi_range(4,40))\r\n\t\t\t\t\tpartic.add_child(par)\r\n\t\t\t\t\tparticulas.append(par)\r\n\t\t\t\tatrator.queue_free()\r\n\t\t\t\tatratores.erase(atrator)\r\n\tif atratores.size() < 3:\r\n\t\tfor i in range(5):\r\n\t\t\tvar atrator = ATRATOR.new(randi_range(0,tamanhoTela.x),randi_range(0,tamanhoTela.y),randi_range(50,200))\r\n\t\t\tatract.add_child(atrator)\r\n\t\t\tatratores.append(atrator)\r\n\tif particulas.size() < 3:\r\n\t\tfor i in range(100):\r\n\t\t\tvar particula = PARTICULA.new(randi_range(0,tamanhoTela.x),randi_range(0,tamanhoTela.y),randi_range(4,40))\r\n\t\t\tpartic.add_child(particula)\r\n\t\t\tparticulas.append(particula)\r\n\tfor i in range(particulas.size() - 1):\r\n\t\tparticulas[i].repulsao(particulas[i+1])\r\n\t\r\n\tfor particula in particulas:\r\n\t\tparticula.no_process()\r\n\r\nfunc _draw():\r\n\tdraw_rect(Rect2(Vector2.ZERO, tamanhoTela),'000000')",
                    "status": "completed",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "Coding-Challenges"
                },
                "Coding Challenge 065 - Binary Tree": {
                    "name": "Coding Challenge 065 - Binary Tree",
                    "description": "This one is just an exemplification of the binary tree algorithm. It chooses a random number between 0 and 1000, then organizes it based on whether it is greater or smaller than the parent number.",
                    "conclusion": "pending completion",
                    "code_ex": "class_name DESENHO\r\nextends Node2D\r\n\r\n@onready var camera_2d = $Camera2D\r\n@onready var folhaCena:PackedScene = preload(\"res:\/\/Cenas\/Folha.tscn\")\r\n\r\nvar arvore:FOLHA = null\r\n\r\nvar valores:Array = []\r\nvar valoresAdicionados:Array = []\r\nvar dist\r\n# Called when the node enters the scene tree for the first time.\r\nfunc _ready():\r\n\tdist = 200\r\n\trandomize()\r\n\tfor i in range(10000):\r\n\t\tvar valor = randi_range(1,1000)\r\n\t\tif !valores.has(valor):\r\n\t\t\tvalores.append(valor)\r\n\tif arvore == null:\r\n\t\tarvore = folhaCena.instantiate()\r\n\t\tarvore.valor = valores.pick_random()\r\n\t\tarvore.position = Vector2(get_viewport().size.x\/2,50)\r\n\t\tadd_child(arvore)\r\n\t\tvalores.erase(arvore.valor)\r\n\r\nfunc _input(event):\r\n\tif Input.is_mouse_button_pressed(MOUSE_BUTTON_WHEEL_DOWN):\r\n\t\tcamera_2d.zoom += Vector2(0.1,0.1)\r\n\tif Input.is_mouse_button_pressed(MOUSE_BUTTON_WHEEL_UP):\r\n\t\tcamera_2d.zoom -= Vector2(0.1,0.1)\r\n\tif Input.is_action_just_pressed(\"ui_accept\"):\r\n\t\tget_tree().reload_current_scene()\r\n\r\n# Called every frame. 'delta' is the elapsed time since the previous frame.\r\nfunc _process(delta):\r\n\tfor i in range(valores.size()):\r\n\t\tif !valoresAdicionados.has(valores[i]):\r\n\t\t\tarvore.adicionar_nova_folha(valores[i], dist, 1, self)\r\n\tfor j in valoresAdicionados.size():\r\n\t\tif valores.has(valoresAdicionados[j]):\r\n\t\t\tvalores.erase(valoresAdicionados[j])\r\n\tprint('a: ', valoresAdicionados.size())\r\n\tprint('b: ', valores.size())\r\n\t\r\n\t#valores.erase(valores[0])\r\n\t#print(valores.size())\r\n\t\r\nfunc _draw():\r\n\tdraw_rect(Rect2(Vector2.ZERO,get_viewport().size),'000000')",
                    "status": "completed",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "Coding-Challenges"
                },
                "Coding Challenge 124 - Flocking Simulation": {
                    "name": "Coding Challenge 124 - Flocking Simulation",
                    "description": "This one emulates a flocking movement pattern. It uses math algorithms to generate this flocking behavior.",
                    "conclusion": "pending completion",
                    "code_ex": "class_name DINO\r\nextends CharacterBody2D\r\n\r\n@onready var animacao:AnimatedSprite2D = $Animacao\r\n@onready var colisao:CollisionShape2D = $Colisao\r\n@onready var area_de_percepcao:Area2D = $AreaDePercepcao\r\n@onready var colisao_da_area:CollisionShape2D = $AreaDePercepcao\/ColisaoDaArea\r\n\r\nvar pos:Vector2 = Vector2(8912.1293,0819273.182)\r\nvar vel:Vector2 = Vector2(8912.1293,0819273.182)\r\nvar ace:Vector2 = Vector2.ZERO\r\n\r\nvar mensagem:String = \"Posicao inicial, velocidade inicial ou tamanho da tela n\u00E3o definidos.\"\r\n\r\nvar maxVel:float = 50.0\r\nvar maxFor:float = 0.2\r\nvar tamTel:Vector2 = Vector2(8912.1293,0819273.182)\r\n\r\nvar mouseDentro:bool = false\r\n\r\n##fun\u00E7\u00E3o responsavel por verificar se o dino foi inicializado corretamente ou n\u00E3o.\r\nfunc _ready():\r\n\tassert(pos != Vector2(8912.1293,0819273.182) && vel != Vector2(8912.1293,0819273.182 && tamTel != Vector2(8912.1293,0819273.182)), mensagem)\r\n\trandomize()\r\n\tativar_posicao_inicial(pos)\r\n\r\n##fun\u00E7\u00E3o responsavel pela inicializa\u00E7\u00E3o da posicao inicial do dino.\r\nfunc ativar_posicao_inicial(posicaoInicial:Vector2) -> void:\r\n\tself.position = posicaoInicial\r\n\r\n##fun\u00E7\u00E3o responsavel pela movimenta\u00E7\u00E3o em contexto geral.\r\nfunc ativar_movimentacao(velocidade:Vector2, dinos:Array) -> void:\r\n\tself.velocity = velocidade\r\n\tmove_and_slide()\r\n\tif mouseDentro:\r\n\t\tself.vel = ace\r\n\t\tself.ace = ace.limit_length(maxVel)\r\n\telse:\r\n\t\tif is_on_wall():\r\n\t\t\tif ace.x > 0:\r\n\t\t\t\tself.ace.x = (ace.x + 600) * -1\r\n\t\t\telse:\r\n\t\t\t\tself.ace.x = (ace.x + 600)\r\n\t\telif is_on_ceiling():\r\n\t\t\tself.ace.y = (ace.y + 600)\r\n\t\telif is_on_floor():\r\n\t\t\tself.vel.y = (vel.y + 600) * -1\r\n\t\telse:\r\n\t\t\tvar distancia:float = self.position.distance_to(dinos[randi_range(0,dinos.size() -1)].position)\r\n\t\t\tif distancia > self.colisao_da_area.shape.radius * 2:\r\n\t\t\t\tself.vel = dinos[0].position.normalized() * maxVel\r\n\t\t\telse:\r\n\t\t\t\tself.vel = Vector2.ZERO\r\n\t\t\tself.ace = ace.limit_length(maxVel)\r\n\r\n##fun\u00E7\u00F5es responsaveis por afastar o dino do mouse.\r\nfunc _quando_mouse_entrar_na_area_de_percepcao():\r\n\tvar direcaoAlvo:Vector2\r\n\tvar posicaoMouse:Vector2 = get_global_mouse_position()\r\n\tvar posicaoAtual:Vector2 = global_position\r\n\tdirecaoAlvo = posicaoAtual - posicaoMouse\r\n\tvel = direcaoAlvo * (maxVel\/3)\r\n\tmouseDentro = true\r\n\r\nfunc _quando_mouse_sair_da_area_de_percepcao():\r\n\tvel = Vector2.ZERO\r\n\tmouseDentro = false\r\n\r\n##fun\u00E7\u00E3o responsavel pelo comportamento do dino ao passar pela borda\r\nfunc bordas() -> void:\r\n\tif self.position.x < 0:\r\n\t\tself.position.x = tamTel.x\r\n\telif self.position.x > tamTel.x:\r\n\t\tself.position.x = 0\r\n\t\r\n\tif self.position.y < 0:\r\n\t\tself.position.y = tamTel.y\r\n\telif self.position.y > tamTel.y:\r\n\t\tself.position.y = 0\r\n\t\t\r\n\tself.pos = position\r\n\r\n##fun\u00E7\u00E3o responsavel por retornar um vetor que alinha o posicionamento de todos os nodos vizinhos.\r\nfunc alinhar(dinos:Array) -> Vector2:\r\n\tvar raioDePercepcao:float = colisao_da_area.shape.radius \/ 2\r\n\tvar direcionar:Vector2 = Vector2.ZERO\r\n\tvar total:int = 0\r\n\tfor dino:DINO in dinos:\r\n\t\tvar distancia:float = self.pos.distance_to(dino.pos)\r\n\t\tif dino != self && distancia < raioDePercepcao:\r\n\t\t\tdirecionar += dino.vel\r\n\t\t\ttotal += 1\r\n\tif total > 0: \r\n\t\tdirecionar = direcionar\/total\r\n\t\tdirecionar = direcionar.normalized() * maxVel\r\n\t\tdirecionar = direcionar - self.vel\r\n\t\tdirecionar = direcionar.limit_length(maxFor)\r\n\treturn direcionar.normalized()\r\n\r\n##fun\u00E7\u00E3o responsavel por retornar um vetor que separa os dinos em uma dire\u00E7\u00E3o oposta a que os visinhos est\u00E3o\r\nfunc separar(dinos:Array) -> Vector2:\r\n\tvar raioDePercepcao:float = colisao_da_area.shape.radius \/3\r\n\tvar direcionar:Vector2 = Vector2.ZERO\r\n\tvar total:int = 0\r\n\tfor dino:DINO in dinos:\r\n\t\tvar distancia:float = self.pos.distance_to(dino.pos)\r\n\t\tif dino != self && distancia < raioDePercepcao:\r\n\t\t\tvar diferenca:Vector2 = self.pos - dino.pos\r\n\t\t\tdiferenca = diferenca\/(distancia * distancia)\r\n\t\t\tdirecionar += diferenca\r\n\t\t\ttotal += 1\r\n\tif total > 0:\r\n\t\tdirecionar = direcionar\/total\r\n\t\tdirecionar = direcionar.normalized() * maxVel\r\n\t\tdirecionar = direcionar - self.vel\r\n\t\tdirecionar = direcionar.limit_length(maxFor)\r\n\treturn direcionar.normalized()\r\n\r\n##fun\u00E7\u00E3o responsavel por retornar um vetor que indica a dire\u00E7\u00E3o que os dinos precisam andar para se manter em bando.\r\nfunc coagir(dinos:Array) -> Vector2:\r\n\tvar raioDePercepcao:float = colisao_da_area.shape.radius\r\n\tvar direcionar:Vector2 = Vector2.ZERO\r\n\tvar total:int = 0\r\n\tfor dino:DINO in dinos:\r\n\t\tvar distancia:float = self.pos.distance_to(dino.pos)\r\n\t\tif dino != self && distancia < raioDePercepcao:\r\n\t\t\tdirecionar += dino.pos\r\n\t\t\ttotal += 1\r\n\tif total > 0:\r\n\t\tdirecionar = direcionar\/total\r\n\t\tdirecionar = direcionar - self.pos\r\n\t\tdirecionar = direcionar.normalized() * maxVel\r\n\t\tdirecionar = direcionar - self.vel\r\n\t\tdirecionar = direcionar.limit_length(maxFor)\r\n\treturn direcionar.normalized()\r\n\r\nfunc rebanho(dinos:Array) -> void:\r\n\tvar alinhamento:Vector2 = self.alinhar(dinos)\r\n\tvar coesao:Vector2 = self.coagir(dinos)\r\n\tvar separacao:Vector2 = self.separar(dinos)\r\n\t\r\n\tself.ace += alinhamento + coesao + separacao\r\n\t\r\n\tself.pos = position\r\n\r\n##fun\u00E7\u00E3o responsavel pelo calculo de fisica do dino.\r\nfunc no_processamento_de_fisica(_delta:float,dinos:Array) -> void:\r\n\tself.pos = position\r\n\tself.vel += self.ace\r\n\tself.vel.limit_length(self.maxVel)\r\n\tativar_movimentacao(vel,dinos)\r\n\t\r\n\t\r\n\t\r\n\t",
                    "status": "completed",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "Coding-Challenges"
                },
                "Coding Challenge 125 - Fourier Series": {
                    "name": "Coding Challenge 125 - Fourier Series",
                    "description": "This one shows a graphical representation of the Fourier series algorithm.",
                    "conclusion": "pending completion",
                    "code_ex": "class_name DESENHO\r\nextends Node2D\r\n\r\nvar componente_inicial:float = 100\r\nvar fator_de_multiplicacao:float = 4\r\nvar modificador_de_tamanho_de_circulos_subsequentes:float = 2.0 #o valor tem que ser >= 0\r\nvar quantidade_de_circulos:int = 10\r\nvar velocidade_de_rotacao:float = 0.016\r\nvar tamanho_do_offset:float = 300\r\n\r\nvar tempo:float = 0.0\r\nvar caminho:Array = []\r\nvar onda:Array = []\r\n\r\nvar tamanhoTela:Vector2 = Vector2(1920,1080)\r\nvar linha:Line2D\r\nvar cores:Array = []\r\n\r\nfunc _ready():\r\n\tiniciar_tamanho_da_tela()\r\n\tiniciar_linha()\r\n\t\r\n\tfor i in range(quantidade_de_circulos):\r\n\t\tvar cor:Color = Color(randf_range(0,1),randf_range(0,1),randf_range(0,1),1)\r\n\t\tcores.append(cor)\r\n\r\nfunc _input(_event):\r\n\tif Input.is_action_just_pressed('q'):\r\n\t\tcomponente_inicial += 1\r\n\telif Input.is_action_just_pressed('a'):\r\n\t\tcomponente_inicial -= 1\r\n\telif Input.is_action_just_pressed('w'):\r\n\t\tfator_de_multiplicacao += 0.1\r\n\telif Input.is_action_just_pressed('s'):\r\n\t\tfator_de_multiplicacao -= 0.1\r\n\telif Input.is_action_just_pressed('e'):\r\n\t\tmodificador_de_tamanho_de_circulos_subsequentes += 0.1\r\n\telif Input.is_action_just_pressed('d'):\r\n\t\tmodificador_de_tamanho_de_circulos_subsequentes -= 0.1\r\n\telif Input.is_action_just_pressed('r'):\r\n\t\tquantidade_de_circulos += 1\r\n\t\tfor i in range(quantidade_de_circulos):\r\n\t\t\tif i >= cores.size():\r\n\t\t\t\tvar cor:Color = Color(randf_range(0,1),randf_range(0,1),randf_range(0,1),1)\r\n\t\t\t\tcores.append(cor)\r\n\telif Input.is_action_just_pressed('f'):\r\n\t\tquantidade_de_circulos -= 1\r\n\telif Input.is_action_just_pressed('t'):\r\n\t\tvelocidade_de_rotacao += 0.016\r\n\telif Input.is_action_just_pressed('g'):\r\n\t\tvelocidade_de_rotacao -= 0.016\r\n\telif Input.is_action_just_pressed('y'): \r\n\t\ttamanho_do_offset += 25\r\n\telif Input.is_action_just_pressed('h'): \r\n\t\ttamanho_do_offset -= 25\r\n\r\n\r\nfunc iniciar_tamanho_da_tela() -> void:\r\n\tget_viewport().size = Vector2i(tamanhoTela)\r\n\r\nfunc iniciar_linha() -> void:\r\n\tlinha = Line2D.new()\r\n\tfor i in range(tamanhoTela.x - tamanho_do_offset*2):\r\n\t\tlinha.add_point(Vector2(i+tamanho_do_offset*2,tamanhoTela.y\/2))\r\n\tlinha.width = 1\r\n\tadd_child(linha)\r\n\r\nfunc _draw():\r\n\tdraw_rect(Rect2(Vector2(0,0),tamanhoTela),Color('000000'))\r\n\t\r\n\tvar x:float = 0.0\r\n\tvar y:float = 0.0\r\n\t\r\n\tfor i in range(quantidade_de_circulos):\r\n\t\tvar x_antigo:float = x\r\n\t\tvar y_antigo:float = y\r\n\t\t\r\n\t\tvar numero_de_circulos:float = i * modificador_de_tamanho_de_circulos_subsequentes + 1\r\n\t\tvar raio = componente_inicial * (fator_de_multiplicacao \/ (numero_de_circulos * PI))\r\n\t\t\r\n\t\tx += raio * cos(numero_de_circulos * tempo)\r\n\t\ty += raio * sin(numero_de_circulos * tempo)\r\n\t\t\r\n\t\t\r\n\t\tdraw_circle(Vector2(x+tamanho_do_offset,y+(tamanhoTela.y\/2)),4,'ff0000')\r\n\t\tdraw_arc(Vector2(x_antigo+tamanho_do_offset,y_antigo+(tamanhoTela.y\/2)),raio,0,359,360,cores[i],1)\r\n\t\r\n\tonda.push_front(y)\r\n\t\r\n\tdraw_line(Vector2(x+tamanho_do_offset,y+(tamanhoTela.y\/2)),Vector2(0+tamanho_do_offset*2,onda[0]+(tamanhoTela.y\/2)),'ffff00',1)\r\n\t\r\n\t\r\n\tfor i in range(onda.size()):\r\n\t\tif i < tamanhoTela.x - tamanho_do_offset*2:\r\n\t\t\tlinha.set_point_position(i,Vector2(i+tamanho_do_offset*2,onda[i]+tamanhoTela.y\/2))\r\n\t\telse:\r\n\t\t\tonda.pop_back()\r\n\t\r\n\ttempo += velocidade_de_rotacao\r\n\r\nfunc _process(_delta):\r\n\tpass\r\n\r\nfunc _physics_process(_delta):\r\n\tqueue_redraw()",
                    "status": "completed",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "Coding-Challenges"
                },
                "Coding Challenge 126 - Tothpick Fractal": {
                    "name": "Coding Challenge 126 - Tothpick Fractal",
                    "description": "This fractal creates an image using the rule that every line can only be connected by another line at each of its ends.",
                    "conclusion": "pending completion",
                    "code_ex": "class_name PALITO\r\nextends Node2D\r\n\r\nvar posicao_lado_a:Vector2\r\nvar posicao_lado_b:Vector2\r\n\r\nvar linha:Line2D\r\nvar largura:float\r\nvar tamanho:float\r\nvar direcao:int\r\nvar novo_palito:bool\r\n\r\nvar proximo_palito_a:PALITO\r\nvar proximo_palito_b:PALITO\r\n\r\nvar tamanho_tela:Vector2\r\n\r\nfunc _ready():\r\n\tpass\r\n\r\nfunc _init(pX:float, pY:float, d:int, l:float,t:float, tT:Vector2) -> void:\r\n\tnovo_palito = true\r\n\tlargura = l\r\n\ttamanho = t\r\n\ttamanho_tela = tT\r\n\tdirecao = d\r\n\tif direcao == -1:\r\n\t\tposicao_lado_a = Vector2(pX-tamanho\/2, pY)\r\n\t\tposicao_lado_b = Vector2(pX+tamanho\/2, pY)\r\n\telse:\r\n\t\tposicao_lado_a = Vector2(pX, pY-tamanho\/2)\r\n\t\tposicao_lado_b = Vector2(pX, pY+tamanho\/2)\r\n\r\nfunc iniciar_linha(nodoPai:Node2D) -> void:\r\n\tlinha = Line2D.new()\r\n\tlinha.width = largura\r\n\tlinha.add_point(posicao_lado_a)\r\n\tlinha.add_point(posicao_lado_b)\r\n\tnodoPai.add_child(linha)\r\n\r\nfunc intersepta(x:float,y:float) -> bool:\r\n\tif self.posicao_lado_a.x == x && self.posicao_lado_a.y == y:\r\n\t\treturn true\r\n\telif self.posicao_lado_b.x == x && self.posicao_lado_b.y == y:\r\n\t\treturn true\r\n\telse:\r\n\t\treturn false\r\n\r\nfunc criar_palito(outros_palitos:Array):\r\n\tvar disponiveis:Array = [null, null]\r\n\tvar disponivel_a:bool = true\r\n\tvar disponivel_b:bool = true\r\n\tfor outro in outros_palitos:\r\n\t\tif outro != self:\r\n\t\t\tif outro.intersepta(self.posicao_lado_a.x, self.posicao_lado_a.y):\r\n\t\t\t\tdisponivel_a = false\r\n\t\t\tif outro.intersepta(self.posicao_lado_b.x, self.posicao_lado_b.y):\r\n\t\t\t\tdisponivel_b = false\r\n\tif disponivel_a:\r\n\t\tproximo_palito_a = PALITO.new(posicao_lado_a.x, posicao_lado_a.y, direcao * -1, largura, tamanho, tamanho_tela)\r\n\t\tdisponiveis[0] = proximo_palito_a\r\n\tif disponivel_b:\r\n\t\tproximo_palito_b = PALITO.new(posicao_lado_b.x, posicao_lado_b.y, direcao * -1, largura, tamanho, tamanho_tela)\r\n\t\tdisponiveis[1] = proximo_palito_b\r\n\treturn disponiveis\r\n\r\nfunc _process(_delta):\r\n\tif !self.novo_palito:\r\n\t\tpass",
                    "status": "completed",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "Coding-Challenges"
                },
                "Coding Challenge 127 - Floco de neve de árvore browniana": {
                    "name": "Coding Challenge 127 - Floco de neve de árvore browniana",
                    "description": "This challenge is incomplete. It only shows a brief section of the snowflake. The way I was making this made it laggy and glitchy, so I chose to try again later. So, don't execute this one.",
                    "conclusion": "pending completion",
                    "code_ex": "class_name PARTICULA\r\nextends Node2D\r\n\r\nvar posicao:Vector2\r\nvar raio:float\r\nvar cor:Color\r\n\r\nfunc _init(Angulo:float, RaioTela:float, RaioCirculo:float = 2, corCirculo:Color = 'ffffff') -> void:\r\n\tposicao = Vector2.from_angle(Angulo)\r\n\tposicao = _escalonar_vetor(RaioTela)\r\n\traio = RaioCirculo\r\n\tcor = corCirculo\r\n\tadd_to_group('particula')\r\n\r\nfunc _escalonar_vetor(valor:float) -> Vector2:\r\n\tvar novo_eixo_X = posicao.x * valor\r\n\tvar novo_eixo_Y = posicao.y * valor\r\n\tvar retorno:Vector2 = Vector2(novo_eixo_X,novo_eixo_Y)\r\n\treturn retorno\r\n\r\nfunc atualizar() -> void:\r\n\tself.posicao.x -= 1\r\n\tself.posicao.y -= randf_range(-3,3)\r\n\t\r\n\tvar angulo = posicao.angle()\r\n\tangulo = _limitar_angulo(angulo, 0, PI\/6)\r\n\tvar magnitude = posicao.length()\r\n\tself.posicao = Vector2.RIGHT.rotated(angulo).normalized() * magnitude\r\n\r\nfunc _draw():\r\n\tdraw_circle(posicao, raio, cor)\r\n\r\nfunc _limitar_angulo(angulo:float, limite_inicial:float, limite_final:float) -> float:\r\n\tvar ang:float = angulo\r\n\tif ang < limite_inicial:\r\n\t\tang = limite_inicial\r\n\tif ang > limite_final:\r\n\t\tang = limite_final\r\n\treturn ang\r\n\r\nfunc intersepta(flocosDeNeve:Array) -> bool:\r\n\tvar retorno:bool = false\r\n\tfor floco:PARTICULA in flocosDeNeve:\r\n\t\tvar distancia:float = self.posicao.distance_to(floco.posicao)\r\n\t\tif distancia < raio*2:\r\n\t\t\tretorno = true\r\n\t\t\tbreak\r\n\treturn retorno\r\n\r\nfunc terminado() -> bool:\r\n\tif self.posicao.x < 1:\r\n\t\treturn true\r\n\treturn false",
                    "status": "incomplete",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "Coding-Challenges"
                },
                "Coding Challenge 145 - Raycast": {
                    "name": "Coding Challenge 145 - Raycast",
                    "description": "This is a visual representation of the raycast algorithm. It is used to show how objects 'see' in the virtual world.",
                    "conclusion": "pending completion",
                    "code_ex": "class_name DESENHO\r\nextends Node2D\r\n\r\nvar paredes:Array = []\r\nvar raio:RAIO\r\nvar Particula:PARTICULA\r\nvar tamanhoTela:Vector2\r\n\r\nfunc _ready() -> void:\r\n\ttamanhoTela = get_viewport().size\r\n\tinicializar()\r\n\tdesenhar()\r\n\r\nfunc inicializar() -> void:\r\n\tfor i in range(5):\r\n\t\tvar x1 = randi_range(0,tamanhoTela.x)\r\n\t\tvar y1 = randi_range(0,tamanhoTela.y)\r\n\t\tvar x2 = randi_range(0,tamanhoTela.x)\r\n\t\tvar y2 = randi_range(0,tamanhoTela.y)\r\n\t\tparedes.append(PAREDE.new(x1,y1,x2,y2)) \r\n\tparedes.append(PAREDE.new(-1,-1,tamanhoTela.x, -1))\r\n\tparedes.append(PAREDE.new(tamanhoTela.x, -1, tamanhoTela.x, tamanhoTela.y))\r\n\tparedes.append(PAREDE.new(tamanhoTela.x,tamanhoTela.y,-1,tamanhoTela.y))\r\n\tparedes.append(PAREDE.new(-1, tamanhoTela.y, -1,-1))\r\n\tParticula = PARTICULA.new(tamanhoTela.x\/2,tamanhoTela.y\/2)\r\n\tprint(Particula.posicao)\r\n\t\r\n\r\nfunc desenhar() -> void:\r\n\tfor parede:PAREDE in paredes:\r\n\t\tparede.revelar(self, randf_range(5,10))\r\n\t\t\r\n\tParticula.revelar(self,2)\r\n\tfor raio in Particula.raios:\r\n\t\traio.revelar(self)\r\n\r\nfunc _process(_delta):\r\n\tParticula.atualizar(get_local_mouse_position().x, get_local_mouse_position().y)\r\n\tParticula.olhar(paredes,self)\r\n\t\r\n\t",
                    "status": "completed",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "Coding-Challenges"
                },
                "Coding Challenge 162 - Self Avoiding Walk": {
                    "name": "Coding Challenge 162 - Self Avoiding Walk",
                    "description": "This is a visual representation of how you can make something move through an area in a way that it checks every possible path and chooses one that touches every part of the path without crossing the same path twice. It is an inefficient way to move, but it is a certain way to verify that it will not collide with itself.",
                    "conclusion": "pending completion",
                    "code_ex": "class_name DESENHO\r\nextends Node2D\r\n\r\n@onready var camera_2d = $Camera2D\r\n\r\nvar grid:Array\r\nvar espaco:float = 50\r\nvar colunas:float\r\nvar linhas:float\r\nvar caminho:Array = []\r\nvar local:LOCALIDADE\r\nvar tamanhoTela:Vector2\r\nvar linha:Line2D\r\n\r\nfunc _ready() -> void:\r\n\ttamanhoTela = Vector2(350,350)#get_viewport().size\r\n\tcolunas = round(tamanhoTela.x \/ espaco) \r\n\tlinhas = round(tamanhoTela.y \/ espaco)\r\n\tgrid = criar_array_bidimensional(colunas, linhas)\r\n\tfor x in range(colunas):\r\n\t\tfor y in range(linhas):\r\n\t\t\tgrid[x][y] = LOCALIDADE.new(x,y,espaco)\r\n\t\r\n\tlocal = grid[colunas\/2][linhas\/2]\r\n\tcaminho.append(local)\r\n\tlocal.visitado = true\r\n\tlinha = Line2D.new()\r\n\tlinha.width = 0.5\r\n\tadd_child(linha)\r\n\tcamera_2d.zoom = Vector2(50,50)\r\n\r\nfunc _process(_delta) -> void:\r\n\tdesenhar()\r\n\r\nfunc _input(_event):\r\n\tif Input.is_mouse_button_pressed(MOUSE_BUTTON_WHEEL_DOWN):\r\n\t\tcamera_2d.zoom += Vector2(10,10)\r\n\t\tprint(camera_2d.zoom)\r\n\telif Input.is_mouse_button_pressed(MOUSE_BUTTON_WHEEL_UP):\r\n\t\tcamera_2d.zoom -= Vector2(10,10)\r\n\t\tif camera_2d.zoom < Vector2(0.2,0.2):\r\n\t\t\tcamera_2d.zoom = Vector2(0.1,0.1)\r\n\telif Input.is_action_just_pressed(\"ui_down\"):\r\n\t\tcamera_2d.position.y += 10\r\n\t\tprint(camera_2d.position)\r\n\telif Input.is_action_just_pressed('ui_up'):\r\n\t\tcamera_2d.position.y -= 10\r\n\t\tprint(camera_2d.position)\r\n\telif Input.is_action_just_pressed('ui_left'):\r\n\t\tcamera_2d.position.x -= 10\r\n\t\tprint(camera_2d.position)\r\n\telif Input.is_action_just_pressed('ui_right'):\r\n\t\tcamera_2d.position.x += 10\r\n\t\tprint(camera_2d.position)\r\n\telif Input.is_action_just_pressed(\"ui_accept\"):\r\n\t\tget_tree().reload_current_scene()\r\n\t\t\r\n\r\nfunc desenhar() -> void:\r\n\tlocal = local.proximo_local(self)\r\n\tif !local:\r\n\t\tvar travado:LOCALIDADE = caminho.pop_back()\r\n\t\ttravado.limpar()\r\n\t\tlocal = caminho[caminho.size() - 1]\r\n\telse:\r\n\t\tcaminho.append(local)\r\n\t\tlocal.visitado = true\r\n\t\r\n\tif caminho.size() == colunas * linhas:\r\n\t\tprint('Resolvido!')\r\n\t\tset_process(false)\r\n\r\n\tvar path_vertices = []\r\n\tfor loc:LOCALIDADE in caminho:\r\n\t\tpath_vertices.append(Vector2(loc.posicao.x, loc.posicao.y))\r\n\r\n\tlinha.points = path_vertices\r\n\r\nfunc criar_array_bidimensional(col:float,lin:float) -> Array:\r\n\tvar arrayDeColunas:Array = []\r\n\tfor x in range(col):\r\n\t\tvar arrayDeLinhas:Array = []\r\n\t\tfor y in range(lin):\r\n\t\t\tarrayDeLinhas.append(null)\r\n\t\tarrayDeColunas.append(arrayDeLinhas)\r\n\treturn arrayDeColunas\r\n\t\t",
                    "status": "completed",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "Coding-Challenges"
                },
                "Coding Challenge 182 - Fractal de Junta Apolônica": {
                    "name": "Coding Challenge 182 - Fractal de Junta Apolônica",
                    "description": "This is a visual representation of a fractal. It works by generating circles with different diameters that have to be connected by only one section.",
                    "conclusion": "pending completion",
                    "code_ex": "extends Node2D\r\n\r\n@onready var circulo:PackedScene = preload(\"res:\/\/Cenas\/Circulo.tscn\")\r\n@onready var timer = $Timer\r\n@onready var timer_2 = $Timer2\r\n\r\nvar todosCirculos:Array\r\nvar fila:Array\r\nvar count:int = 1\r\n\r\n\r\n# Called when the node enters the scene tree for the first time.\r\nfunc _ready():\r\n\tcriar_circulos()\r\n\t\t\r\nfunc gerar_novo_circulo() -> void:\r\n\tvar novafila = []\r\n\tfor tripla in fila:\r\n\t\tvar c1 = tripla[0]\r\n\t\tvar c2 = tripla[1]\r\n\t\tvar c3 = tripla[2]\r\n\t\tvar k4 = descartes(c1,c2,c3)\r\n\t\tvar novosCirculos = descartesComplexo(c1,c2,c3,k4)\r\n\t\t\r\n\t\tfor nc in novosCirculos:\r\n\t\t\tif validar(nc, c1, c2, c3):\r\n\t\t\t\ttodosCirculos.append(nc)\r\n\t\t\t\tvar t1 = [c1, c2, nc]\r\n\t\t\t\tvar t2 = [c2, c3, nc]\r\n\t\t\t\tvar t3 = [c1, c3, nc]\r\n\t\t\t\tnovafila.append_array([t1,t2,t3]) \r\n\t\t\t\tnovo_circulo(nc)\r\n\tfila.append_array(novafila)\r\n\r\nfunc validar(c4:CIRCULO, c1:CIRCULO, c2:CIRCULO, c3:CIRCULO) -> bool:\r\n\tif c4.raio < 5: return false\r\n\t\r\n\tfor outro:CIRCULO in todosCirculos:\r\n\t\tvar pos1 = c4.global_position\r\n\t\tvar pos2 = outro.global_position\r\n\t\tvar dist = abs(pos1.distance_to(pos2))\r\n\t\tvar difRaio = abs(c4.raio - outro.raio)\r\n\t\tvar eps = 0.1\r\n\t\t\r\n\t\tif dist < eps && difRaio < eps:\r\n\t\t\treturn false\r\n\t\r\n\tif !ehTangente(c4,c1): return false\r\n\tif !ehTangente(c4,c2): return false\r\n\tif !ehTangente(c4,c3): return false\r\n\t\r\n\treturn true\r\n\r\nfunc ehTangente(c1:CIRCULO, c2:CIRCULO) -> bool:\r\n\tvar r1 = c1.raio\r\n\tvar r2 = c2.raio\r\n\tvar pos1 = c1.global_position\r\n\tvar pos2 = c2.global_position\r\n\tvar dist = pos1.distance_to(pos2)\r\n\tvar eps = 0.1\r\n\t\r\n\tvar boleana1:bool = abs(dist - (r1 + r2)) < eps\r\n\tvar boleana2:bool = abs(dist - abs(r2 - r1)) < eps\r\n\t\r\n\tif boleana1 || boleana2:\r\n\t\treturn true\r\n\telse:\r\n\t\treturn false\r\n\r\nfunc criar_circulos() -> void:\r\n\tvar viewportTamanho = get_viewport().size\r\n\tvar x = viewportTamanho.x\r\n\tvar y = viewportTamanho.y\r\n\t\r\n\tvar circulo_instancia_1:CIRCULO = circulo.instantiate()\r\n\tcirculo_instancia_1.iniciarValores(x\/2,y\/2,-1.0\/(x\/2))\r\n\tcirculo_instancia_1.montarCirculo()\r\n\ttodosCirculos += [circulo_instancia_1]\r\n\t\r\n\tvar r2 = randf_range(circulo_instancia_1.centro.a\/8, circulo_instancia_1.raio)\r\n\tvar v = Vector2(cos(randf_range(0, TAU)), sin(randf_range(0, TAU)))\r\n\tv = set_mag(v, circulo_instancia_1.raio - r2)\r\n\r\n\tvar circulo_instancia_2:CIRCULO = circulo.instantiate()\r\n\tcirculo_instancia_2.iniciarValores(circulo_instancia_1.centro.a + v.x, circulo_instancia_1.centro.b + v.y, 1.0\/r2)\r\n\tcirculo_instancia_2.montarCirculo()\r\n\ttodosCirculos += [circulo_instancia_2]\r\n\t\r\n\t\r\n\tvar r3 = circulo_instancia_1.raio - circulo_instancia_2.raio\r\n\tv.rotated(PI)\r\n\tvar v3 = set_mag(v, circulo_instancia_1.raio - r3)\r\n\t\r\n\tvar circulo_instancia_3:CIRCULO = circulo.instantiate()\r\n\tcirculo_instancia_3.iniciarValores(circulo_instancia_1.centro.a - v3.x, circulo_instancia_1.centro.b - v3.y, 1.0\/r3)\r\n\tcirculo_instancia_3.montarCirculo()\r\n\ttodosCirculos += [circulo_instancia_3]\r\n\t\r\n\tfor circ in todosCirculos:\r\n\t\tnovo_circulo(circ)\r\n\tfila = [[circulo_instancia_1, circulo_instancia_2, circulo_instancia_3]]\r\n\r\nfunc set_mag(vetor: Vector2, comprimento: float) -> Vector2:\r\n\tif vetor == Vector2.ZERO:\r\n\t\treturn vetor \r\n\telse:\r\n\t\treturn vetor.normalized() * comprimento\r\n\r\nfunc novo_circulo(circ:CIRCULO):\r\n\tcirc.name = str(count)\r\n\tadd_child(circ)\r\n\tcount += 1\r\n\r\nfunc descartes(circulo1:CIRCULO,circulo2:CIRCULO,circulo3:CIRCULO) -> Array:\r\n\tvar curvatura1 = circulo1.curvatura\r\n\tvar curvatura2 = circulo2.curvatura\r\n\tvar curvatura3 = circulo3.curvatura\r\n\t\r\n\tvar soma = curvatura1 + curvatura2 + curvatura3\r\n\tvar produto = abs(curvatura1*curvatura2 + curvatura2*curvatura3 + curvatura1*curvatura3)\r\n\tvar raiz = 2* sqrt(produto)\r\n\t\r\n\tvar resultado = [soma + raiz, soma - raiz]\r\n\treturn resultado\r\n\r\nfunc descartesComplexo(circulo1:CIRCULO, circulo2:CIRCULO, circulo3:CIRCULO, curvaturaCirculo4:Array) -> Array:\r\n\tvar curvatura1:float = circulo1.curvatura\r\n\tvar curvatura2:float = circulo2.curvatura\r\n\tvar curvatura3:float = circulo3.curvatura\r\n\tvar centro1:COMPLEXOS = circulo1.centro\r\n\tvar centro2:COMPLEXOS = circulo2.centro\r\n\tvar centro3:COMPLEXOS = circulo3.centro\r\n\t\r\n\tvar CurCen1:COMPLEXOS = centro1.scalonar(curvatura1)\r\n\tvar CurCen2:COMPLEXOS = centro2.scalonar(curvatura2)\r\n\tvar CurCen3:COMPLEXOS = centro3.scalonar(curvatura3)\r\n\t\r\n\tvar soma:COMPLEXOS = CurCen1.somar(CurCen2).somar(CurCen3)\r\n\tvar raiz:COMPLEXOS = CurCen1.multiplicar(CurCen2).somar(CurCen2.multiplicar(CurCen3)).somar(CurCen1.multiplicar(CurCen3))\r\n\traiz = raiz.raizQuadrada().scalonar(2)\r\n\t\r\n\tvar cen1 = soma.somar(raiz).scalonar(1.0\/curvaturaCirculo4[0])\r\n\tvar cen2 = soma.subtrair(raiz).scalonar(1.0\/curvaturaCirculo4[0])\r\n\tvar cen3 = soma.somar(raiz).scalonar(1.0\/curvaturaCirculo4[1])\r\n\tvar cen4 = soma.subtrair(raiz).scalonar(1.0\/curvaturaCirculo4[1])\r\n\t\r\n\tvar retorno = []\r\n\t\r\n\tvar circulo_instancia_1:CIRCULO = circulo.instantiate()\r\n\tcirculo_instancia_1.iniciarValores(cen1.a,cen1.b,curvaturaCirculo4[0])\r\n\tcirculo_instancia_1.montarCirculo()\r\n\tretorno += [circulo_instancia_1]\r\n\t\r\n\tvar circulo_instancia_2:CIRCULO = circulo.instantiate()\r\n\tcirculo_instancia_2.iniciarValores(cen2.a,cen2.b,curvaturaCirculo4[0])\r\n\tcirculo_instancia_2.montarCirculo()\r\n\tretorno += [circulo_instancia_2]\r\n\t\r\n\tvar circulo_instancia_3:CIRCULO = circulo.instantiate()\r\n\tcirculo_instancia_3.iniciarValores(cen3.a,cen3.b,curvaturaCirculo4[1])\r\n\tcirculo_instancia_3.montarCirculo()\r\n\tretorno += [circulo_instancia_3]\r\n\t\r\n\tvar circulo_instancia_4:CIRCULO = circulo.instantiate()\r\n\tcirculo_instancia_4.iniciarValores(cen4.a,cen4.b,curvaturaCirculo4[1])\r\n\tcirculo_instancia_4.montarCirculo()\r\n\tretorno += [circulo_instancia_4]\r\n\t\r\n\treturn retorno\r\n\r\nfunc _on_timer_timeout():\r\n\tvar len1 = todosCirculos.size()\r\n\t\r\n\tgerar_novo_circulo()\r\n\t\r\n\tvar len2 = todosCirculos.size()\r\n\t\r\n\tif len1 == len2:\r\n\t\ttimer.stop()\r\n\t\ttimer_2.start()\r\n\r\n\r\nfunc reiniciar() -> void:\r\n\tif timer.is_stopped():\r\n\t\tvar filhos = get_children()\r\n\t\tfor filho in filhos:\r\n\t\t\tif filho != timer && filho != timer_2:\r\n\t\t\t\ttodosCirculos.erase(filho)\r\n\t\t\t\tfilho.queue_free()\r\n\t\r\n\tcriar_circulos()\r\n\ttimer.start()\r\n\r\n\r\nfunc _on_timer_2_timeout():\r\n\treiniciar()",
                    "status": "completed",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "Coding-Challenges"
                },
                "Coding Challenge 115 - Tabela de curvas de Lissajous": {
                    "name": "Coding Challenge 115 - Tabela de curvas de Lissajous",
                    "description": "This one shows a table of how different velocities in two circles change the moving trajectory of a third point.",
                    "conclusion": "pending completion",
                    "code_ex": "class_name DESENHO\r\nextends Node2D\r\n\r\nvar angulo:float = 0.0\r\nvar largura:float = 50\r\nvar colunas:int\r\nvar linhas:int\r\nvar curvas:Array\r\nvar tamanhoTela:Vector2i\r\nvar diametro:float\r\nvar raio:float\r\nvar reguas_x:Array \r\nvar reguas_y:Array\r\n\r\nfunc _ready():\r\n\ttamanhoTela = Vector2i(600,600)\r\n\tajustar_tamanho_de_tela(tamanhoTela)\r\n\tcolunas = tamanhoTela.x \/ largura\r\n\tlinhas = tamanhoTela.y \/ largura\r\n\tcurvas = criar_array_2d(colunas,linhas)\r\n\tdiametro = largura - (0.2 * largura)\r\n\traio = diametro\/2\r\n\t\r\n\tfor x in range(colunas):\r\n\t\tvar centroEixoX1:float = (x * largura) + (largura\/2)\r\n\t\tvar centroEixoY1:float = largura\/2\r\n\t\t\r\n\t\tvar eixoX1:float = raio * cos(angulo * (x) - PI\/2)\r\n\t\tvar eixoY1:float = raio * sin(angulo * (x) - PI\/2)\r\n\t\t\r\n\t\tfor y in range(linhas):\r\n\t\t\tvar centroEixoX2:float = largura\/2\r\n\t\t\tvar centroEixoY2:float = (y * largura) + (largura\/2)\r\n\t\t\t\r\n\t\t\tvar eixoX2:float = raio * cos(angulo * (y) - PI\/2)\r\n\t\t\tvar eixoY2:float = raio * sin(angulo * (y) - PI\/2)\r\n\t\t\t\r\n\t\t\tif x != 0:\r\n\t\t\t\treguas_x.append(REGUA.new(0, centroEixoX1 + eixoX1, tamanhoTela.y, centroEixoY1 + eixoY1, self, false))\r\n\t\t\tif y != 0:\r\n\t\t\t\treguas_y.append(REGUA.new(0, centroEixoX2 + eixoX2, tamanhoTela.x, centroEixoY2 + eixoY2, self, true))\r\n\r\n\tfor x in range(colunas):\r\n\t\tfor y in range(linhas):\r\n\t\t\tcurvas[x][y] = CURVA.new(self)\r\n\r\n\r\nfunc ajustar_tamanho_de_tela(tamanho:Vector2i) -> void:\r\n\tget_viewport().size = tamanho\r\n\r\nfunc criar_array_2d(eixoX:float, eixoY:float) -> Array:\r\n\tvar arrayDeRetorno:Array = []\r\n\tfor x in range(eixoX):\r\n\t\tvar arrayInterno:Array = []\r\n\t\tfor y in range(eixoY):\r\n\t\t\tarrayInterno.append(null)\r\n\t\tarrayDeRetorno.append(arrayInterno)\r\n\treturn arrayDeRetorno\r\n\r\nfunc iniciar_cabecario() -> void:\r\n\tfor x in range(colunas):\r\n\t\tvar centroEixoX1:float = (x * largura) + (largura\/2)\r\n\t\tvar centroEixoY1:float = largura\/2\r\n\t\t\r\n\t\tvar eixoX1:float = raio * cos(angulo * (x) - PI\/2)\r\n\t\tvar eixoY1:float = raio * sin(angulo * (x) - PI\/2)\r\n\t\t\r\n\t\tfor y in range(linhas):\r\n\t\t\tvar centroEixoX2:float = largura\/2\r\n\t\t\tvar centroEixoY2:float = (y * largura) + (largura\/2)\r\n\t\t\t\r\n\t\t\tvar eixoX2:float = raio * cos(angulo * (y) - PI\/2)\r\n\t\t\tvar eixoY2:float = raio * sin(angulo * (y) - PI\/2)\r\n\t\t\t\r\n\t\t\tcurvas[x][0].iniciar_eixo_x_e_eixo_y(centroEixoX1 + eixoX1, centroEixoY1 + eixoY1)\r\n\t\t\tcurvas[0][y].iniciar_eixo_x_e_eixo_y(centroEixoX2 + eixoX2, centroEixoY2 + eixoY2)\r\n\t\t\tget_child(get_children().find(curvas[0][0].ponto) -1).hide()\r\n\t\t\t\r\n\t\r\nfunc iniciar_tabela() -> void:\r\n\tfor x in range(colunas):\r\n\t\tif x != 0:\r\n\t\t\tfor y in range(linhas):\r\n\t\t\t\tvar centroEixoX:float = (x * largura) + (largura\/2)\r\n\t\t\t\tvar centroEixoY:float = (y * largura) + (largura\/2)\r\n\t\t\t\r\n\t\t\t\tvar eixoX:float = raio * cos(angulo * (x) - PI\/2)\r\n\t\t\t\tvar eixoY:float = raio * sin(angulo * (y) - PI\/2)\r\n\t\t\t\tif y != 0:\r\n\t\t\t\t\tcurvas[x][y].iniciar_eixo_x_e_eixo_y(centroEixoX + eixoX, centroEixoY + eixoY)\r\n\r\nfunc desenhar_tabela() -> void:\r\n\tfor x in range(colunas):\r\n\t\tfor y in range(linhas):\r\n\t\t\tif x != 0:\r\n\t\t\t\treguas_x[x].movimentar_regua(curvas[x][y].atual)\r\n\t\t\tif y != 0:\r\n\t\t\t\treguas_y[y].movimentar_regua(curvas[x][y].atual)\r\n\t\t\tcurvas[x][y].ponto.atualizar_posicao(curvas[x][y].atual)\r\n\t\t\tcurvas[x][y].adicionar_ponto()\r\n\t\t\tcurvas[x][y].desenhar()\r\n\t\r\n\tangulo -= 0.01\r\n\t\r\n\tif angulo < - PI * 2 :\r\n\t\tfor x in range(colunas):\r\n\t\t\tfor y in range(linhas):\r\n\t\t\t\tcurvas[x][y].resetar()\r\n\t\tangulo = 0\r\n\r\nfunc _process(_delta) -> void:\r\n\tiniciar_cabecario()\r\n\tiniciar_tabela()\r\n\tdesenhar_tabela()",
                    "status": "completed",
                    "icon": "https://via.placeholder.com/50x50",
                    "Tecnologia": "GDScript",
                    "projeto": "Coding-Challenges"
                }
            },
            "code_Ex": "# Coding Train Challenges in Godot\r\n\r\nThat was one of my takes on the challenges made by the YouTuber Daniel Shiffman from the channel The Coding Train. He uses JAVA to solve mathematical problems. These were the ones that I could try to make using Godot. These projects were made when I was learning how to use the tools at my disposal, so some may be glitchy or not work properly, and I plan on remaking them someday.\r\n\r\n## How to Check the Results\r\n1. Go to the `EXECUTAVEIS` folder and choose the project you want to see.\r\n2. Download the .RAR file, extract it, and execute the .EXE file. (If the project has two .EXE files, you can choose either.)\r\n3. The vast majority of the programs do not have interfaces and will start as soon as you start the program.\r\n4. Some projects may have special commands, which I will explain later.\r\n\r\n## Coding Challenges\r\n\r\n### CODING CHALLENGE 001 -> Starfield Simulation\r\nThis one was a simulation of a 3D plane in a 2D canvas. It is a math problem that tries to show how perspective can emulate a moving object.\r\n\r\n**How to use:**\r\n- You can control the velocity of the particles by pressing the UP or DOWN arrow keys.\r\n\r\n<div align=\"center\">\r\n  <img src=\"https:\/\/github.com\/user-attachments\/assets\/2367fb76-9efe-4575-a227-cdb75fe16247\" alt=\"Starfield Simulation GIF\" width=\"300\"\/>\r\n<\/div>\r\n\r\n### CODING CHALLENGE 010 -> Maze Generator\r\nThis one was a challenge of how you can generate a random maze using an algorithm to check the next best possible way.\r\n\r\n**How to use:**\r\n- You can restart the maze by pressing the space bar.\r\n\r\n<div align=\"center\">\r\n  <img src=\"https:\/\/github.com\/user-attachments\/assets\/1b77fe6d-bcd8-43b9-abc7-8624e7e209b7\" alt=\"Maze Generator GIF\" width=\"300\"\/>\r\n<\/div>\r\n\r\n### CODING CHALLENGE 015 -> Fractal Trees\r\nThis one uses the classical fractal problem to create a tree.\r\n\r\n**How to use:**\r\n- It has no special commands.\r\n\r\n<div align=\"center\">\r\n  <img src=\"https:\/\/github.com\/user-attachments\/assets\/dcbf06aa-0251-4044-9393-b7809988126c\" alt=\"Fractal Trees GIF\" width=\"300\"\/>\r\n<\/div>\r\n\r\n### CODING CHALLENGE 021 -> Mandelbrot Set\r\nThis one is an illustration of the Mandelbrot set. It changes the color of every pixel on the screen to white or black. If it's white, it is out of the Mandelbrot set. This one is in urgent need of a remake because it is laggy. The way I chose to change the color was not optimal; it should have been made with a shader.\r\n\r\n**How to use:**\r\n- If you for some reason wish to see the redraw, you can press the space bar to restart.\r\n\r\n<div align=\"center\">\r\n  <img src=\"https:\/\/github.com\/user-attachments\/assets\/8a2e9b19-d00e-4c2a-870b-1eb62bdea8b6\" alt=\"Mandelbrot Set Print\" width=\"300\"\/>\r\n<\/div>\r\n\r\n### CODING CHALLENGE 033 -> Poisson-Disc Sample\r\nThis one is a graphical representation of the Poisson-disc sample algorithm. It is used to create multiple random points on a canvas where none of the points are too far away or too close to another point. The program is finished when the canvas only has blue dots.\r\n\r\n**How to use:**\r\n- If you wish to see another representation, you can press the space bar to restart.\r\n\r\n<div align=\"center\">\r\n  <img src=\"https:\/\/github.com\/user-attachments\/assets\/144929a0-d350-47af-9bef-b120ad26facb\" alt=\"Poisson-Disc Sample GIF\" width=\"300\"\/>\r\n<\/div>\r\n\r\n### CODING CHALLENGE 054 -> Islamic Star Pattern\r\nThis one is a graphical representation of the classical Islamic tiles that you can see in buildings. It uses math to calculate the new shapes and create beautiful images.\r\n\r\n**How to use:**\r\n- You can use the sliders to change the size, quantity, and angles to create new images.\r\n- You can use the color bars to change the colors of the lines.\r\n\r\n<div align=\"center\">\r\n  <img src=\"https:\/\/github.com\/user-attachments\/assets\/879976c1-183f-459f-b141-07fa7f54434c\" alt=\"Islamic Star Pattern GIF\" width=\"300\"\/>\r\n<\/div>\r\n\r\n### CODING CHALLENGE 056 -> Attraction Forces\r\nThis one is just an emulation of the attraction forces. The pink circles attract the white circles. The bigger the pink circle, the greater the force. The velocity of the white circle is obtained by calculating the influence of the pink circle's mass on the white circle's mass. The mass is represented by the size of the circle.\r\n\r\n**How to use:**\r\n- It has no special commands.\r\n\r\n<div align=\"center\">\r\n  <img src=\"https:\/\/github.com\/user-attachments\/assets\/c2ef98a8-cfdf-43e3-97d8-c719eaca4e89\" alt=\"Attraction Forces GIF\" width=\"300\"\/>\r\n<\/div>\r\n\r\n### CODING CHALLENGE 065 -> Binary Tree\r\nThis one is just an exemplification of the binary tree algorithm. It chooses a random number between 0 and 1000, then organizes it based on whether it is greater or smaller than the parent number.\r\n\r\n**How to use:**\r\n- Every time you press the space bar, you can see a new tree being generated.\r\n\r\n<div align=\"center\">\r\n  <img src=\"https:\/\/github.com\/user-attachments\/assets\/3c240eae-8279-48f1-8ef1-53ad11dbcd0d\" alt=\"Binary Tree GIF\" width=\"300\"\/>\r\n<\/div>\r\n\r\n### CODING CHALLENGE 115 -> Tabela de Curvas de Lissajous\r\nThis one shows a table of how different velocities in two circles change the moving trajectory of a third point.\r\n\r\n**How to use:**\r\n- It has no special commands.\r\n\r\n<div align=\"center\">\r\n  <img src=\"https:\/\/github.com\/user-attachments\/assets\/7e4b90bb-b554-4cd4-b762-d14b211625d6\" alt=\"Tabela de Curvas de Lissajous GIF\" width=\"300\"\/>\r\n<\/div>\r\n\r\n### CODING CHALLENGE 124 -> Flocking Simulation\r\nThis one emulates a flocking movement pattern. It uses math algorithms to generate this flocking behavior.\r\n\r\n**How to use:**\r\n- It has no special commands.\r\n\r\n<div align=\"center\">\r\n  <img src=\"https:\/\/github.com\/user-attachments\/assets\/7cb3391c-580f-4a24-a4db-f2bf4f024090\" alt=\"Flocking Simulation GIF\" width=\"300\"\/>\r\n<\/div>\r\n\r\n### CODING CHALLENGE 125 -> Fourier Series\r\nThis one shows a graphical representation of the Fourier series algorithm.\r\n\r\n**How to use:**\r\n- You can change the initial component with: Q & A\r\n- You can change the multiplication factor with: W & S\r\n- You can change the subsequent circle sizes with: E & D\r\n- You can change the quantity of circles with: R & F\r\n- You can change the rotation velocity with: T & G\r\n- You can change the offset with: Y & H\r\n\r\n<div align=\"center\">\r\n  <img src=\"https:\/\/github.com\/user-attachments\/assets\/7d68ec75-b110-408a-8412-727d729f15bd\" alt=\"Fourier Series GIF\" width=\"300\"\/>\r\n<\/div>\r\n\r\n### CODING CHALLENGE 126 -> Toothpick Fractal\r\nThis fractal creates an image using the rule that every line can only be connected by another line at each of its ends.\r\n\r\n**How to use:**\r\n- You can restart the animation by pressing the space bar.\r\n- You can also add a new set of toothpicks using the right mouse button.\r\n\r\n<div align=\"center\">\r\n  <img src=\"https:\/\/github.com\/user-attachments\/assets\/0292478c-9353-46de-8506-e26279b84e6c\" alt=\"Toothpick Fractal GIF\" width=\"300\"\/>\r\n<\/div>\r\n\r\n### CODING CHALLENGE 127 -> Floco de Neve de \u00C1rvore Browniana\r\nThis challenge is incomplete. It only shows a brief section of the snowflake. The way I was making this made it laggy and glitchy, so I chose to try again later. So, don't execute this one.\r\n\r\n**How to use:**\r\n- Don't use it.\r\n\r\n<div align=\"center\">\r\n  <img src=\"https:\/\/github.com\/user-attachments\/assets\/34774a5b-3240-4df7-a929-924b1260594f\" alt=\"Floco de Neve de \u00C1rvore Browniana GIF\" width=\"300\"\/>\r\n<\/div>\r\n\r\n### CODING CHALLENGE 145 -> Raycast\r\nThis is a visual representation of the raycast algorithm. It is used to show how objects \"see\" in the virtual world.\r\n\r\n**How to use:**\r\n- Move the mouse to see what changes.\r\n\r\n<div align=\"center\">\r\n  <img src=\"https:\/\/github.com\/user-attachments\/assets\/2e477306-df9a-44dc-a577-f745322f8fde\" alt=\"Raycast GIF\" width=\"300\"\/>\r\n<\/div>\r\n\r\n### CODING CHALLENGE 162 -> Self Avoiding Walk\r\nThis is a visual representation of how you can make something move through an area in a way that it checks every possible path and chooses one that touches every part of the path without crossing the same path twice. It is an inefficient way to move, but it is a certain way to verify that it will not collide with itself.\r\n\r\n**How to use:**\r\n- If it is taking too long to finish, you can restart by pressing the space bar. It will probably take too long to finish again.\r\n\r\n<div align=\"center\">\r\n  <img src=\"https:\/\/github.com\/user-attachments\/assets\/9c652618-a441-4e1e-bbeb-ffa6fb1d2032\" alt=\"Self Avoiding Walk GIF\" width=\"300\"\/>\r\n<\/div>\r\n\r\n### CODING CHALLENGE 182 -> Fractal de Junta Apol\u00F4nica\r\nThis is a visual representation of a fractal. It works by generating circles with different diameters that have to be connected by only one section.\r\n\r\n**How to use:**\r\n- It has no special commands.\r\n\r\n<div align=\"center\">\r\n  <img src=\"https:\/\/github.com\/user-attachments\/assets\/b69a1af6-4af9-4f99-89b2-35e91c7e0765\" alt=\"Fractal de Junta Apol\u00F4nica GIF\" width=\"300\"\/>\r\n<\/div>\r\n\r\n\r\n",
            "conclusion": "A ideia por tras desse repositorio é relambrar e/ou aprender novos conceitos, algoritmos e/ou tecnicas de programação. Ao adotar os desafios propostos eu consegui conhecer mais a fundo a linguagem GDScript e o motor Godot. Servindo como um bom ponto de entrada para conceitos complexos e avançados de programação.",
            "icon": "https://via.placeholder.com/50x50",
            "status": "incomplete"
        },
        "EBAC_Fullstack_Python": {
            "name": "EBAC_Fullstack_Python",
            "subproject": {},
            "code_ex": "README\r\nReposit\u00F3rio de Projetos do Curso de \"Fullstack Python\" da EBAC\r\nEsse reposit\u00F3rio consta com todos os projetos feitos durante o curso de fullstack python ministrado pela EBAC. No decorrer do curso, foram explicadas as principais ferramentas utilizadas no frontend e backend de uma aplica\u00E7\u00E3o. Os pontos de destaque do curso foram o desenvolvimento de aplica\u00E7\u00F5es utilizando VUE, CRA e DJANGO. As principais linguagens utilizadas foram Python, JavaScript e Typescript.\r\n\r\nFormas de Executar as Aplica\u00E7\u00F5es\r\nExistem 4 formas diferentes de executar as aplica\u00E7\u00F5es demonstradas aqui:\r\n\r\nP\u00E1ginas HTML: Os projetos mais simples s\u00E3o compostos de apenas p\u00E1ginas HTML simples, ent\u00E3o a sua execu\u00E7\u00E3o \u00E9 direta atrav\u00E9s do navegador.\r\nAplica\u00E7\u00F5es VUE: Os projetos realizados atrav\u00E9s do VUE precisam ser rodados atrav\u00E9s do comando npm run dev.\r\nAplica\u00E7\u00F5es CRA: Os projetos realizados atrav\u00E9s do CRA precisam ser rodados atrav\u00E9s do comando npm start.\r\nAplica\u00E7\u00F5es DJANGO: Os projetos realizados atrav\u00E9s do DJANGO precisam ser rodados atrav\u00E9s do comando python manage.py runserver.\r\nAplica\u00E7\u00F5es Simples: Os projetos com apenas arquivos .JS, .TS ou .PY precisam ser executados de maneira individualizada utilizando sua ferramenta de leitura de prefer\u00EAncia.\r\nProjetos de Destaque\r\nTodos os projetos solicitados no curso foram executados e aprovados pela equipe da EBAC. Os projetos de destaque s\u00E3o:\r\n\r\nProjeto 1 -> GameShop: Foi o primeiro projeto solicitado pela EBAC, visando mostrar o dom\u00EDnio de HTML e CSS.\r\nProjeto 2 -> Calculadora de M\u00E9dias: Foi o segundo projeto solicitado pela EBAC, visando mostrar o dom\u00EDnio de HTML, CSS e JavaScript.\r\nProjeto 3 -> Bootstrap Landing Page: Foi o terceiro projeto solicitado pela EBAC, visando mostrar o dom\u00EDnio do framework Bootstrap.\r\nProjeto 4 -> Disney Plus Clone: Foi o quarto projeto solicitado pela EBAC, visando mostrar o dom\u00EDnio das ferramentas de deploy e estrutura\u00E7\u00E3o de projeto.\r\nProjeto 5 -> Lista de Contatos: Foi o quinto projeto solicitado pela EBAC, visando mostrar o dom\u00EDnio da ferramenta CRA (Create React App).\r\nProjeto 6 -> Efood: Foi o sexto projeto solicitado pela EBAC, visando mostrar o dom\u00EDnio das ferramentas de frontend. Nele foi utilizado CRA (Create React App).\r\nProjeto 7 -> Twitter Clone: Foi o s\u00E9timo projeto solicitado pela EBAC, visando mostrar o dom\u00EDnio das ferramentas de frontend e das ferramentas de backend. No frontend foi utilizado VUE e no backend Django.\r\nRepository of \"Fullstack Python\" Course Projects by EBAC\r\nThis repository contains all the projects completed during the Fullstack Python course provided by EBAC. Throughout the course, the main tools used in the frontend and backend of an application were explained. The course highlights were developing applications using VUE, CRA, and DJANGO. The primary languages used were Python, JavaScript, and Typescript.\r\n\r\nHow to Run the Applications\r\nThere are 4 different ways to run the applications demonstrated here:\r\n\r\nHTML Pages: The simpler projects are composed of just simple HTML pages, so they can be run directly through the browser.\r\nVUE Applications: Projects developed with VUE need to be run using the command npm run dev.\r\nCRA Applications: Projects developed with CRA need to be run using the command npm start.\r\nDJANGO Applications: Projects developed with DJANGO need to be run using the command python manage.py runserver.\r\nSimple Applications: Projects with just .JS, .TS, or .PY files need to be run individually using your preferred reading tool.\r\nHighlighted Projects\r\nAll the projects requested during the course were executed and approved by the EBAC team. The highlighted projects are:\r\n\r\nProject 1 -> GameShop: It was the first project requested by EBAC, aiming to demonstrate proficiency in HTML and CSS.\r\nProject 2 -> Average Calculator: It was the second project requested by EBAC, aiming to demonstrate proficiency in HTML, CSS, and JavaScript.\r\nProject 3 -> Bootstrap Landing Page: It was the third project requested by EBAC, aiming to demonstrate proficiency in the Bootstrap framework.\r\nProject 4 -> Disney Plus Clone: It was the fourth project requested by EBAC, aiming to demonstrate proficiency in deployment tools and project structuring.\r\nProject 5 -> Contact List: It was the fifth project requested by EBAC, aiming to demonstrate proficiency in the CRA (Create React App) tool.\r\nProject 6 -> Efood: It was the sixth project requested by EBAC, aiming to demonstrate proficiency in frontend tools. CRA (Create React App) was used.\r\nProject 7 -> Twitter Clone: It was the seventh project requested by EBAC, aiming to demonstrate proficiency in frontend and backend tools. VUE was used on the frontend and Django on the backend.",
            "Conclusion": "",
            "icon": "https://via.placeholder.com/50x50",
            "status": "completed"
        }
    },
    "cursos": {
        "Entendendo e documentando REST/RESTful APIs": {
            "name": "Entendendo e documentando REST/RESTful APIs",
            "icon": "https://via.placeholder.com/50x50",
            "code_cert": "UC-0efbcf5b-4f45-47b2-a4ce-c0491989dcbe",
            "status": "completed",
            "descricao": "pending description",
            "url": "https://www.udemy.com/certificate/UC-0efbcf5b-4f45-47b2-a4ce-c0491989dcbe/",
            "Tecnologia": "Desconhecida",
            "escola": "Udemy"
        },
        "Vue JS - Guia Completo (Vue CLI, Vue Router, Vuex, GraphQl)": {
            "name": "Vue JS - Guia Completo (Vue CLI, Vue Router, Vuex, GraphQl)",
            "icon": "https://via.placeholder.com/50x50",
            "code_cert": "UC-a0c86f79-94db-4fc8-8b92-40b3474b898a",
            "status": "completed",
            "descricao": "pending description",
            "url": "https://www.udemy.com/certificate/UC-a0c86f79-94db-4fc8-8b92-40b3474b898a/",
            "Tecnologia": "Vue",
            "escola": "Udemy"
        },
        "Vue JS 3 - Completo com composition API, Vuex & Vue Router": {
            "name": "Vue JS 3 - Completo com composition API, Vuex & Vue Router",
            "icon": "https://via.placeholder.com/50x50",
            "code_cert": "UC-f395e35b-4bb8-4acc-8e4c-d783dc3c66d6",
            "status": "completed",
            "descricao": "pending description",
            "url": "https://www.udemy.com/certificate/UC-f395e35b-4bb8-4acc-8e4c-d783dc3c66d6/",
            "Tecnologia": "Vue",
            "escola": "Udemy"
        },
        "Inteligencia Artificial": {
            "name": "Inteligencia Artificial",
            "icon": "https://via.placeholder.com/50x50",
            "code_cert": "59883-78431-79265-99097",
            "status": "completed",
            "descricao": "pending description",
            "url": "https://lms.ebaconline.com.br/certs/validate/59883-78431-79265-99097",
            "Tecnologia": "Desconhecida",
            "escola": "EBAC"
        },
        "Profissão: TI do Zero ao Pro": {
            "name": "Profissão: TI do Zero ao Pro",
            "icon": "https://via.placeholder.com/50x50",
            "code_cert": "24707-78431-66074-01337",
            "status": "completed",
            "descricao": "pending description",
            "url": "https://lms.ebaconline.com.br/certs/validate/24707-78431-66074-01337",
            "Tecnologia": "JavaScript",
            "escola": "EBAC"
        },
        "Profissão: Desenvolvedor Full Stack Python": {
            "name": "Profissão: Desenvolvedor Full Stack Python",
            "icon": "https://via.placeholder.com/50x50",
            "code_cert": "14791-78431-01551-40560",
            "status": "completed",
            "descricao": "pending description",
            "url": "https://lms.ebaconline.com.br/certs/validate/14791-78431-01551-40560",
            "Tecnologia": "Python",
            "escola": "EBAC"
        },
        "Introdução a programação": {
            "name": "Introdução a programação",
            "icon": "https://via.placeholder.com/50x50",
            "code_cert": "48683-78431-14927-89532",
            "status": "completed",
            "descricao": "pending description",
            "url": "https://lms.ebaconline.com.br/certs/validate/48683-78431-14927-89532",
            "Tecnologia": "C++",
            "escola": "EBAC"
        },
        "Complete Godot 4 2d: Code Your Own 2D Game": {
            "name": "Complete Godot 4 2d: Code Your Own 2D Game",
            "icon": "https://via.placeholder.com/50x50",
            "code_cert": "Not Avaible",
            "status": "completed",
            "descricao": "pending description",
            "url": "https://www.gamedev.tv/courses/godot-complete-2d",
            "Tecnologia": "GDScript",
            "escola": "GameDev.tv"
        },
        "Godot 4 Shaders: Craft Stunning Visuals": {
            "name": "Godot 4 Shaders: Craft Stunning Visuals",
            "icon": "https://via.placeholder.com/50x50",
            "code_cert": "Not Avaible",
            "status": "completed",
            "descricao": "Master the Art of Shading: From Basic Techniques to Advanced Visual Effects in 2D and 3D Environments",
            "url": "https://www.gamedev.tv/courses/godot-shaders",
            "Tecnologia": "GDShader",
            "escola": "GameDev.tv"
        },
        "Godot 4 Multiplayer: Make Your Own Online Game": {
            "name": "Godot 4 Multiplayer: Make Your Own Online Game",
            "icon": "https://via.placeholder.com/50x50",
            "code_cert": "Not Avaible",
            "status": "completed",
            "descricao": "Start creating multiplayer games in Godot 4 with GDScript and W4 Cloud!",
            "url": "https://www.gamedev.tv/courses/godot-multiplayer",
            "Tecnologia": "GDScript",
            "escola": "GameDev.tv"
        },
        "Godot 4 C# Action Adventure: Build your own 2.5D RPG": {
            "name": "Godot 4 C# Action Adventure: Build your own 2.5D RPG",
            "icon": "https://via.placeholder.com/50x50",
            "code_cert": "Not Avaible",
            "status": "completed",
            "descricao": "Unleash Your C# Skills in Game Development: Master 2.5D RPG Creation in Godot 4",
            "url": "https://www.gamedev.tv/courses/godot-c-action-adventure",
            "Tecnologia": "C#",
            "escola": "GameDev.tv"
        },
        "Master Mobile Game Development with Godot 4: From Concept to App Stores": {
            "name": "Master Mobile Game Development with Godot 4: From Concept to App Stores",
            "icon": "https://via.placeholder.com/50x50",
            "code_cert": "Not Avaible",
            "status": "completed",
            "descricao": "Build a complete feature-rich mobile game, including gameplay, UI system, in-game shop, saving system and more.",
            "url": "https://www.gamedev.tv/courses/godot-mobile",
            "Tecnologia": "GDScript",
            "escola": "GameDev.tv"
        },
        "Complete Godot 3D: Code Your Own 3D Games In Godot 4!": {
            "name": "Complete Godot 3D: Code Your Own 3D Games In Godot 4!",
            "icon": "https://via.placeholder.com/50x50",
            "code_cert": "Not Avaible",
            "status": "completed",
            "descricao": "Learn how to create 3D games from start to finish in Godot engine 4 and GDScript!",
            "url": "https://www.gamedev.tv/courses/godot-complete-3d",
            "Tecnologia": "GDScript",
            "escola": "GameDev.tv"
        }
    }
}
